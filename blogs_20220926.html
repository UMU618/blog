 
                                            

                <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='zh-CN' xml:lang='zh-CN' xmlns='http://www.w3.org/1999/xhtml'>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="Content-Language" content="zh-CN"/>
    <title>UMU的博客</title>
    <style>
        body {font:12px/21px Tahoma,"Microsoft Yahei",Geneva,sans-serif;}
        h1 a {color:#40AA53;}
        h1 a,h2 a{text-decoration:none;}
        .backupDesc em {font-style:normal;}
        .blog {margin:0 0 20px 0;border:1px solid #ccc;background:#ffc;padding:10px;}
        .blog h2 {border-bottom:1px solid #ccc;padding:0 0 10px 0;}
        .blog h2 a.top {float:right;font-weight:normal;font-size:9pt;}
        .blog .outline {background:#fff;border:1px solid #eee;padding:10px;color:#666;}

        .commentList {margin:20px 0 0 0;}
        .comment {margin:0 0 10px 0; border:1px solid #ddd; background:#ffe;padding:5px;}
        .comment .author {float:left;font-weight:bold;}
        .comment .date {float:left;margin:0 0 0 10px;}
        .comment .content {clear:left;margin:5px 0 0 0;}
    </style>
</head>
<body>
<h1><a name='top' href="https://my.oschina.net/umu618/blog">UMU的博客@OSCHINA</a></h1>
<p class='backupDesc'>共有<em>116</em>篇文章，备份时间：2022-09-26 22:51:00</p>
<ol>
            <li><a href="#blog_80290">UMU 选定开源中国为技术博客</a></li>
            <li><a href="#blog_82867">从 Windows 8 新功能推理某产品的八哥</a></li>
            <li><a href="#blog_82959">[UMU WSH 教程](42) FSO 应用实例 - 批量删除文件</a></li>
            <li><a href="#blog_82960">[UMU WSH 教程](43) WIA 应用实例 - 批量转换图片格式</a></li>
            <li><a href="#blog_83984">mif2png（QQGame 专用 mif 格式转 png 格式）</a></li>
            <li><a href="#blog_90115">图像格式转换之 Jpeg2Jxr</a></li>
            <li><a href="#blog_90192">用树莓派 + USB 无线网卡做了一个蛋疼的 AP Client</a></li>
            <li><a href="#blog_93199">拯救 TL-WR941N V4.1 路由器</a></li>
            <li><a href="#blog_95163">开发 LSP 遇到的蛋疼问题</a></li>
            <li><a href="#blog_98025">XP 下 Edit 控件透明字体时的 Bug</a></li>
            <li><a href="#blog_98039">判断系统是不是 XP</a></li>
            <li><a href="#blog_108520">天翼宽带智能提速</a></li>
            <li><a href="#blog_114156">协议加速的三个时代</a></li>
            <li><a href="#blog_117397">枚举物理网卡</a></li>
            <li><a href="#blog_117635">快游为什么是现在这样</a></li>
            <li><a href="#blog_117644">快游简史</a></li>
            <li><a href="#blog_117854">开发 LSP 遇到的蛋疼问题 - 解释原理篇</a></li>
            <li><a href="#blog_119745">程序员心法三则</a></li>
            <li><a href="#blog_123553">解析一下 Windows 的快捷方式居然这么难……</a></li>
            <li><a href="#blog_126213">坑爹的 VS2012 Update 2！居然不支持 XP 了！含解决方案！</a></li>
            <li><a href="#blog_129428">开发 Windows RT 桌面应用（来自 Surface RT）</a></li>
            <li><a href="#blog_133901">[UMU WSH 教程](44) WII 应用实例 - 查找重复文件</a></li>
            <li><a href="#blog_151098">加速器是网游的 CDN</a></li>
            <li><a href="#blog_151859">只留哈希不留种</a></li>
            <li><a href="#blog_167024">[UMU WSH 教程](45) WIA 应用实例 - 按图片拍摄时间批量重命名</a></li>
            <li><a href="#blog_214675">DuiLib 经验：控件没有 GetRect 接口？</a></li>
            <li><a href="#blog_264935">Windows 8 和 OpenWRT 下查看 WiFi 属性</a></li>
            <li><a href="#blog_267435">跟 UMU 一起玩 OpenWRT（高级篇1）：编译不死 U-Boot</a></li>
            <li><a href="#blog_267912">跟 UMU 一起玩 OpenWRT（高级篇2）：不拆机刷不死 U-Boot</a></li>
            <li><a href="#blog_268466">跟 UMU 一起玩 OpenWRT（入门篇1）：硬件选型和刷机</a></li>
            <li><a href="#blog_269744">极路由升级保留 root 方法</a></li>
            <li><a href="#blog_271630">跟 UMU 一起玩 OpenWRT（入门篇2）：连上路由器</a></li>
            <li><a href="#blog_272249">考题：为什么 Shell 脚本自动把字符串 10001 当成二进制，输出 17？</a></li>
            <li><a href="#blog_272515">安全性堪忧的门禁系统</a></li>
            <li><a href="#blog_273945">跟 UMU 一起玩 OpenWRT（入门篇3）：工作模式开关</a></li>
            <li><a href="#blog_279956">极路由 1S 使用经验</a></li>
            <li><a href="#blog_279963">小米路由使用经验</a></li>
            <li><a href="#blog_280295">跟 UMU 一起玩 OpenWRT（入门篇4）：启用工作模式开关和联网</a></li>
            <li><a href="#blog_282223">跟 UMU 一起玩 OpenWRT（入门篇5）：升级固件</a></li>
            <li><a href="#blog_282984">跟 UMU 一起玩 OpenWRT（入门篇6）：挂接 U 盘</a></li>
            <li><a href="#blog_284552">跟 UMU 一起玩 OpenWRT（入门篇7）：安装 LUCI</a></li>
            <li><a href="#blog_289572">如意云使用经验</a></li>
            <li><a href="#blog_290697">跟 UMU 一起玩 OpenWRT（入门篇8）：网络摄像机</a></li>
            <li><a href="#blog_293642">跟 UMU 一起玩 OpenWRT（入门篇9）：远程监听</a></li>
            <li><a href="#blog_295193">跟 UMU 一起玩 OpenWRT（入门篇10）：穿透内网</a></li>
            <li><a href="#blog_295195">跟 UMU 一起玩 OpenWRT（入门篇11）：文件共享</a></li>
            <li><a href="#blog_298649">增强 DIR-505 硬件</a></li>
            <li><a href="#blog_309443">考题：关于子类调用父类构造函数</a></li>
            <li><a href="#blog_347216">解决“输入个性化服务”InputPersonalization.exe 占用 CPU 过高的问题</a></li>
            <li><a href="#blog_351007">通过 netlink 的 NETLINK_INET_DIAG 协议获取当前系统所有 TCP 连接信息</a></li>
            <li><a href="#blog_352878">[UMU WSH 教程](46) 按图片拍摄时间批量重命名改进版</a></li>
            <li><a href="#blog_352880">[UMU WSH 教程](47) FSO 应用实例 - 按文件最后修改时间批量重命名</a></li>
            <li><a href="#blog_494665">[UMU 学 golang](1) Hello code!</a></li>
            <li><a href="#blog_495626">[UMU 学 golang](2) 升级 1.5 + 优化</a></li>
            <li><a href="#blog_509647">[UMU 学 golang](3) TCP Echo Server</a></li>
            <li><a href="#blog_510770">[UMU 学 golang](4) 简单的 AWS S3 客户端</a></li>
            <li><a href="#blog_518047">[UMU 学 golang](5) HTTP Echo Server</a></li>
            <li><a href="#blog_542206">newifi mini 刷 OpenWRT</a></li>
            <li><a href="#blog_542900">从“批量导出 QQ 空间说说脚本”的进化谈腾讯对安全性的重视</a></li>
            <li><a href="#blog_546767">吐槽一下 Surface 的扩展坞</a></li>
            <li><a href="#blog_546917">如何比较两个文件是否一样？</a></li>
            <li><a href="#blog_613182">[UMU WSH 教程终结篇](48) FSO 应用实例 - 批量重命名 WP 视频</a></li>
            <li><a href="#blog_667305">Lenovo Y1S 千兆 LAN 改 WAN</a></li>
            <li><a href="#blog_668303">OpenWRT PPTP VPN 穿透</a></li>
            <li><a href="#blog_678118">VS2015 集成 YASM 1.3</a></li>
            <li><a href="#blog_681357">一次 dropbear 和 openssh 冲突的经历</a></li>
            <li><a href="#blog_818839">[C++ 学习笔记 1] delete 和 delete [] 的本质区别</a></li>
            <li><a href="#blog_819390">[C++ 学习笔记 2] 为什么会有移动构造函数、std::move？</a></li>
            <li><a href="#blog_819862">[C++ 学习笔记 3] std::make_shared 和 std::enable_shared_from_this</a></li>
            <li><a href="#blog_821720">[C++ 学习笔记 4] Duff's Device（switch 和 for 穿插）</a></li>
            <li><a href="#blog_827203">[C++ 学习笔记 5] 搞定 asio coroutine 示例</a></li>
            <li><a href="#blog_830602">[C++ 学习笔记 6] 为什么有 std::forward？</a></li>
            <li><a href="#blog_830716">[C++ 学习笔记 7] Effective C++ 条款 1-4</a></li>
            <li><a href="#blog_831411">[C++ 学习笔记 8] Effective C++ 条款 5-12</a></li>
            <li><a href="#blog_839649">[C++ 学习笔记 9] Effective C++ 条款 13-17</a></li>
            <li><a href="#blog_844930">[C++ 学习笔记 10] union 的顺序重要吗？</a></li>
            <li><a href="#blog_848725">跟 UMU 一起玩 OpenWRT（入门篇12）：代理上 QQ</a></li>
            <li><a href="#blog_849345">跟 UMU 一起玩 OpenWRT（入门篇13）：改进 autossh 支持多实例</a></li>
            <li><a href="#blog_850196">[C++ 学习笔记 11] Effective C++ 条款 18-25</a></li>
            <li><a href="#blog_864903">[C++ 学习笔记 12] Effective C++ 条款 26-31</a></li>
            <li><a href="#blog_866469">C++ 11 特征之删除默认成员函数</a></li>
            <li><a href="#blog_867419">完全免费的 Windows Server 系统，不需要序列号、不需要激活、更不需要破解</a></li>
            <li><a href="#blog_916415">解决对话框字体模糊</a></li>
            <li><a href="#blog_1094080">Opus 编解码遇到的怪事</a></li>
            <li><a href="#blog_1153916">解决 Windows 10 无法使用 IrDA</a></li>
            <li><a href="#blog_1154562">Windows 的 WAVEFORMATEX 转 ffmpeg 的 AVSampleFormat 类型</a></li>
            <li><a href="#blog_1189289">UEFI 里的 IGD Minimum Memory 和 IGD Aperture Size</a></li>
            <li><a href="#blog_1335051">[C++ 学习笔记 13] Effective C++ 条款 32-40</a></li>
            <li><a href="#blog_1476439">Windows 的 ChannelMask 转 ffmpeg 的 ChannelLayout</a></li>
            <li><a href="#blog_1476510">把 ffmpeg AVAudioFifo/AVFrame 数据读到共享内存</a></li>
            <li><a href="#blog_1476567">各种录音</a></li>
            <li><a href="#blog_1498766">解决 ffplay 无法播放声音的问题</a></li>
            <li><a href="#blog_1499874">OggFile's CRC checksum</a></li>
            <li><a href="#blog_1510145">OpenWRT PPTP 穿透</a></li>
            <li><a href="#blog_1512603">ffmpeg 与 live555 宏定义冲突</a></li>
            <li><a href="#blog_1518039">AAC 编码之 ADTS 头相关分析</a></li>
            <li><a href="#blog_1553339">内存对齐还是需要重视的——XMMATRIX 为例</a></li>
            <li><a href="#blog_1573044">数据库相关算法 之 xxHash</a></li>
            <li><a href="#blog_1579190">从 pthread_t 获得 PID 和 TID</a></li>
            <li><a href="#blog_1611654">MacBook 只装 Windows 情况下更新 EFI 经验</a></li>
            <li><a href="#blog_1617478">云主机带宽测试一例：Windows Server 网络性能被 Linux 秒杀？</a></li>
            <li><a href="#blog_1617666">Ceph 慢盘原因分析一例：CPU 偷懒了！</a></li>
            <li><a href="#blog_1617683">Mongo Shell 下批量更新集合</a></li>
            <li><a href="#blog_1634881">[UMU 学 golang](6) 从 stdin 读取一行汉字</a></li>
            <li><a href="#blog_1648712">求模版函数地址</a></li>
            <li><a href="#blog_1787996">[UMU 学 golang](7) 设置进程退出码</a></li>
            <li><a href="#blog_1788799">[UMU 学 golang](8) strings.Builder vs bytes.Buffer</a></li>
            <li><a href="#blog_1796683">考题：正则表达式 .*? 和 .* 有区别吗？</a></li>
            <li><a href="#blog_1797528">更新知识库：WinHttpConnect 并不 TCP Connect 和 Punycode</a></li>
            <li><a href="#blog_1800671">MongoDB Shard ID hash 算法 std::hash 的跨平台性</a></li>
            <li><a href="#blog_1805272">C/C++ 数字后缀引发的处女座纠结</a></li>
            <li><a href="#blog_1822051">学习 MongoDB 选举机制</a></li>
            <li><a href="#blog_3209263">技术博客迁移</a></li>
            <li><a href="#blog_4780039">云游戏即将起飞，这些技术您了解吗？</a></li>
            <li><a href="#blog_4873803">鎏光云游戏引擎 FAQ：对高刷新率的支持、与 Moonlight 的比较</a></li>
            <li><a href="#blog_5494853">平台默认不显示评论已经造成不必要的误会</a></li>
    </ol>
<div class='blogList'>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_80290" href="https://my.oschina.net/umu618/blog/80290">UMU 选定开源中国为技术博客</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-09-25 16:22:12</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　第一次在这里写博客，大家可能还不认识 UMU。简单介绍一下吧！ &nbsp;　　UMU 乃“中国好代码”评审之一，今年发布过 32 个 App 哦！是真的 32 个，都可以在“中国好 App”上下载到…… 旧技术博客： http://hi.baidu.com/new/umu618 http://www.cnblogs.com/UMU618/ &nbsp;</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_82867" href="https://my.oschina.net/umu618/blog/82867">从 Windows 8 新功能推理某产品的八哥</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-10-13 02:57:04</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　Windows 8 确实是个不错的系统，DP、CP、RC、RTM，UMU 一路追过来。 　　在开始讲故事之前，要先介绍一下公司的产品——马头流量，http://www.matocloud.com/，也许您没听过，但您可能听过同类产品：上网快鸟、飞速流量、瓦力流量、彩虹流量……当然，这些都是设设 APN 而已，马头的 Android 版本有更高深的技术。想了解更多，请研究一下 EnoVPN。 　　再来是流量压缩原理简介：主要是压缩图片。APN 就是一个 HTTP 代理，只不过这个代理有点不标准，会将原图压缩后交给用户，这样就相当于用户下载了一张小图，自然就省了流量。但这是有副作用的，有的图片必须是有损压缩才会变小，所以也会降低图片质量。知道这个原理后，可能会有人会纠结了……至于您用不用，就看您在图片质量和流量之间的取舍了。 　　故事开始了！UMU 用 HTC Titan 拍过不少图片，当然其中不少是横屏拍的。蛋似，您懂的，这个手机有重力感应功能，所以拍的照片会带 Orientation 信息，这个是 Exif 的一个字段，专业知识请另行搜索“Exif Orientation”。简单讲，无论我拍照时手机是横是竖，我在手机看时，照片都会自动旋转，使景物是正立的。如果您没注意过，可以先在就做这个实验，把 iPhone 倒立拍照，正立过来看，景也会跟着自动转…… 　　当 UMU 把图片同步到电脑上时，情况就不同了。Windows 7 自带的画图、图片查看器都不支持对 Orientation 自动校正，IE9、IE10、Chrome 22.0.1229.94 m、Paint.NET 也都不支持。所以，UMU 是经常看到横屏拍的照片，在 Windows 7 上是显示 90 度旋转的。 　　到了 Windows 8 上，自带的画图、图片查看器都支持 Orientation 校正了！有一天，UMU 在看以前拍的图片时，突然发现，所有的图片都是正立的了…… 　　蛋似，前面有提到 IE10 是不支持的，所以……UMU 特地上传了一张横拍的图片到 TX 微博上，果然这图就是 90 度的，缩略图和原图都是。然后再用 iPhone 看，缩略图是 90 度，这说明&nbsp; TX 微博的缩略图也没考虑 Orientation 信息，点击查看原图，终于正立了，这是因为 iPhone 基本到处都支持 Orientation 自动旋转校正。 　　把这个发现，和马头流量结合起来思考——APN 服务器上的图片压缩程序会不会也没考虑 Orientation 信息？UMU 猜想是很有可能的，TX 就没考虑到……然后开始测试！用 Wifi 去看原图，是正立的，因为 Wifi 下，马头流量不能压缩图片；改用 3G，马头流量开始起作用，然后再去看原图，发生了两件事，大家应该猜到了——图片质量下降了、图片歪了 90 度了！八哥！这就是八哥啊！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_82959" href="https://my.oschina.net/umu618/blog/82959">[UMU WSH 教程](42) FSO 应用实例 - 批量删除文件</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-10-13 23:58:54</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>[UMU WSH 教程](41) 利用 WinHttp.WinHttpRequest.5.1 对象下载文件       UMU WSH 教程代码下载：   http://sdrv.ms/ZpPPaS       UMU WSH Git：http://git.oschina.net/umu618/umu-wsh       &nbsp;       　　使用 VS 的程序员应该都知道，VS 会产生大量临时文件，不少人打包时，经常连这些垃圾都打包进去，导致不必要的增大压缩包……UMU 大学时就写了这个脚本，经历了 VS6 到 VS2012 的变迁，目前还偶尔会用一下这个脚本。       ' 42_DelVBVCTempFile.VBS' UMU @ 0:00 2012/10/14' [UMU WSH 教程](42) FSO 应用实例 - 批量删除文件Option ExplicitOn Error Resume NextConst NUM = 20Const APP_TITLE = "UMU.Script.Tools.DelVBVCTempFiles"Dim objArgs, objFSOSet objFSO = CreateObject("Scripting.FileSystemObject")Set objArgs = WScript.ArgumentsIf objArgs.Count = 0 Then    MsgBox "本程序用来删除 VB &amp; VC 产生无关代码的记录文件。" &amp; vbCrLf &amp; _        "请把要处理的文件夹拖放到本程序的图标上！", 4160, APP_TITLE    Set objArgs = Nothing    Dim objWSH    Dim szSendto, szCopyTo    Set objWSH = CreateObject( "WScript.Shell" )    szSendto = objWSH.SpecialFolders("SendTo")    szCopyTo = szSendto &amp; "\DelVBVCTempFiles_1.1.4.VBE"    If Not objFSO.FileExists(szCopyTo) Then        If vbOK = MsgBox("提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。" &amp; vbCrLf &amp; _            "您的 Sendto 目录是 " &amp; szSendto &amp; vbCrLf &amp; "按“确定”执行复制操作。", _            vbOKCancel + vbInformation, APP_TITLE) Then                        objFSO.CopyFile WScript.ScriptFullName, szCopyTo            If vbYes = MsgBox("是否查看 Sendto 目录？", vbQuestion + vbYesNo, APP_TITLE) Then                objWSH.Run "%SystemRoot%\explorer.exe /n, /select," &amp; szCopyTo            End If        End If    End If    Set objFSO = Nothing    Set objWSH = Nothing    WScript.QuitEnd IfDim ar, i, nCount, g_szExt(20), szErrDelg_szExt(0) = ".ncb"g_szExt(1) = ".plg"g_szExt(2) = ".opt"g_szExt(3) = ".dep"g_szExt(4) = ".mak"g_szExt(5) = ".obj"g_szExt(6) = ".pch"g_szExt(7) = ".idb"g_szExt(8) = ".ilk"g_szExt(9) = ".pdb"g_szExt(10) = ".res"g_szExt(11) = ".aps"g_szExt(12) = ".GID"g_szExt(13) = ".suo"g_szExt(14) = ".scc"g_szExt(15) = ".sbr"g_szExt(16) = ".user"g_szExt(17) = ".intermediate.manifest"g_szExt(18) = ".exp"g_szExt(19) = ".embed.manifest"g_szExt(20) = ".old"szErrDel = "BuildLog.htm、Thumbs.db 和" &amp; vbCrLf &amp; "下面后缀名的文件将被删除：" &amp; vbCrLf &amp; vbCrLfFor i = 0 To NUM    szErrDel = szErrDel &amp; g_szExt(i) &amp; vbCrLfNextszErrDel = szErrDel &amp; vbCrLf &amp; "确定吗？"If vbCancel = MsgBox(szErrDel, vbOKCancel + vbSystemModal + vbQuestion, APP_TITLE) Then    Set objArgs = Nothing    WScript.QuitEnd IfnCount = 0szErrDel = ""For Each ar In objArgs    If objFSO.FolderExists(ar) Then        Call DeleteUseless(ar)    ElseIf objFSO.FileExists(ar) Then        If IsRubbish(objFSO.GetFileName(ar)) Then            objFSO.DeleteFile ar, 1            nCount = nCount + 1        End If    End IfNextMsgBox "总共删除文件 " &amp; nCount &amp; " 个！" &amp; vbCrLf &amp; "下面是没删除的文件：" &amp; szErrDel, 4160, "整个世界清净了！"Private Function IsRubbish( ByVal szFileName )    If StrComp(szFileName, "Thumbs.db", 1) = 0 Then        IsRubbish = True        Exit Function    End If    If StrComp(szFileName, "BuildLog.htm", 1) = 0 Then        IsRubbish = True        Exit Function    End If    Dim szExt, i, nLen    For i = 0 To NUM        nLen = Len(g_szExt(i))        If Len(szFileName) &gt; nLen Then            szExt = Right( szFileName, nLen )            If StrComp(szExt, g_szExt(i), 1) = 0 Then                IsRubbish = True                Exit Function            End If        End If    Next    IsRubbish = FalseEnd FunctionPrivate Sub DeleteUseless( ByVal fd )    On Error Resume Next    Dim rfd, fs, f, fds, p, nf    Set rfd = objFSO.GetFolder(fd)    Set fs = rfd.Files    For Each f In fs        If IsRubbish(f.Name) Then            f.Delete 1            If Err.Number Then                szErrDel = szErrDel &amp; vbCrLf &amp; f.Path                Err.Clear            Else                nCount = nCount + 1            End If        End If    Next    Set fds = rfd.SubFolders    For Each fd In fds        DeleteUseless fd.Path    NextEnd Sub</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_82960" href="https://my.oschina.net/umu618/blog/82960">[UMU WSH 教程](43) WIA 应用实例 - 批量转换图片格式</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-10-14 00:20:42</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>[UMU WSH 教程](42) FSO 应用实例 - 批量删除文件   UMU WSH 教程代码下载：http://sdrv.ms/ZpPPaS   UMU WSH Git：http://git.oschina.net/umu618/umu-wsh   　　bmp 格式的图片占空间比较大，转为无损压缩的 png 格式可以节省空间。下面利用 FSO 和 WIA 对象批量转换 bmp 文件为 png 格式。   &nbsp;  ' 43_bmp2png.VBS' UMU @ 0:23 2012/10/14' [UMU WSH 教程](43) WIA 应用实例 - 批量转换图片格式Option ExplicitConst wiaFormatPNG = &quot;{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}&quot;Const APP_TITLE = &quot;UMU.Script.Tools.bmp2png&quot;Dim objArgs, objFSOSet objArgs = WScript.ArgumentsSet objFSO = CreateObject( &quot;Scripting.FileSystemObject&quot; )If objArgs.Count = 0 Then    Dim objWSH    Dim szSendto, szCopyTo    MsgBox &quot;本程序用来把 bmp 格式图片转换为 png 格式。&quot; &amp; vbCrLf &amp; _        &quot;请把要处理的文件或文件夹拖放到本程序的图标上！&quot;, _        vbInformation, APP_TITLE    Set objWSH = CreateObject( &quot;WScript.Shell&quot; )    szSendto = objWSH.SpecialFolders(&quot;SendTo&quot;)    szCopyTo = szSendto &amp; &quot;\bmp2png.VBE&quot;    If Not objFSO.FileExists(szCopyTo) Then        If vbOK = MsgBox(&quot;本程序用来把 bmp 格式图片转换为 png 格式。&quot; &amp; vbCrLf &amp; _            &quot;请把要处理的文件或文件夹拖放到本程序的图标上！&quot; &amp; vbCrLf &amp; vbCrLf &amp; _            &quot;提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。&quot; &amp; vbCrLf &amp; _            &quot;您的 Sendto 目录是 &quot; &amp; szSendto &amp; vbCrLf &amp; &quot;按“确定”执行复制操作。&quot;, _            vbOKCancel + vbInformation, APP_TITLE) Then                        objFSO.CopyFile WScript.ScriptFullName, szCopyTo            If vbYes = MsgBox(&quot;是否查看 Sendto 目录？&quot;, vbQuestion + vbYesNo, APP_TITLE) Then                objWSH.Run &quot;%SystemRoot%\explorer.exe /n, /select,&quot; &amp; szCopyTo            End If        End If    End If    Set objFSO = Nothing    Set objWSH = Nothing    Set objArgs = Nothing    WScript.QuitEnd IfDim fDeletefDelete = MsgBox( &quot;转换后是否删除原 bmp 文件？&quot;, vbYesNoCancel + vbQuestion, &quot;询问&quot; )If vbCancel = fDelete Then    Set objArgs = Nothing    WScript.QuitEnd IfDim ar, nSucceededCount, nFailedCount, nPngExistsCountnSucceededCount = 0nFailedCount = 0nPngExistsCount = 0For Each ar In objArgs    If objFSO.FolderExists(ar) Then        Call BmpToPng_s(ar)    ElseIf objFSO.FileExists(ar) Then        Call BmpToPng(ar)    End IfNextSet objArgs = NothingSet objFSO = NothingMsgBox &quot;转换 bmp 文件 &quot; &amp; nSucceededCount &amp; &quot; 个，失败 &quot; &amp; nFailedCount &amp; _    &quot; 个，PNG 文件已经存在 &quot; &amp; nPngExistsCount &amp; &quot; 个！&quot;, 4160, &quot;整个世界清净了！&quot;Private Sub BmpToPng_s( ByVal szFolderPath )    'On Error Resume Next    Dim rfd, fs, f, fds, fd    Set rfd = objFSO.GetFolder( szFolderPath )    Set fs = rfd.Files    For Each f In fs        BmpToPng f.Path    Next    Set fds = rfd.SubFolders    For Each fd In fds        BmpToPng_s fd.Path    NextEnd SubPrivate Sub BmpToPng( ByVal szFilePath )    On Error Resume Next    Dim szExt, szPng    szExt = Right( szFilePath, 4 )    If StrComp( szExt, &quot;.bmp&quot;, vbTextCompare ) Then        Exit Sub    End If    szPng = Left(szFilePath, Len(szFilePath) - 4) &amp; &quot;.png&quot;    If objFSO.FileExists(szPng) Then        nPngExistsCount = nPngExistsCount + 1        Exit Sub    End If    Err.Clear    Dim objIF, objIP    Set objIF = CreateObject( &quot;WIA.ImageFile&quot; )    Set objIP = CreateObject( &quot;WIA.ImageProcess&quot; )    objIF.LoadFile szFilePath    If Err.Number Then        nFailedCount = nFailedCount + 1        Exit Sub    End If    If objIF.FormatID &lt;&gt; wiaFormatPNG Then        objIP.Filters.Add objIP.FilterInfos(&quot;Convert&quot;).FilterID        objIP.Filters(1).Properties(&quot;FormatID&quot;).Value = wiaFormatPNG        Set objIF = objIP.Apply(objIF)        objIF.SaveFile szPng        If Err.Number Then            Set objIF = Nothing            Set objIP = Nothing            nFailedCount = nFailedCount + 1            Exit Sub        End If        nSucceededCount = nSucceededCount + 1        If vbYes = fDelete Then            objFSO.DeleteFile szFilePath        End If    End If    Set objIF = Nothing    Set objIP = NothingEnd Sub</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_83984" href="https://my.oschina.net/umu618/blog/83984">mif2png（QQGame 专用 mif 格式转 png 格式）</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-10-19 17:29:45</div>
                <div class='catalog'>分类：.NET</div>
                                                                            </div>
            <div class='content'>2011-11-26 00:27 发布于 http://hi.baidu.com/umu618/item/207ca93ae23d34c7392ffa0e，属于开源代码，转到此处。   　　大学时代的作品《UMU 游戏之争上游》的副产品，mif2bmp 改进版，用 GdiPlus 来产生 png 格式图片。   　　mif2png.exe 下载：http://download.csdn.net/detail/umu/3843545   　　以前有文章分析 mif 格式，不过很早了懒得找，直接开源吧，先发头部结构体：  #pragma pack(1)struct MifHeader{    DWORD version;    DWORD width;    DWORD height;    DWORD type;    DWORD frame_count;};#pragma pack()  &nbsp;   以下代码是 C# 写的 Paint.NET 文件类型插件 MifFileType.cs  using System;using System.Collections.Generic;using System.Text;using PaintDotNet;using PaintDotNet.Data;using System.IO;using System.Drawing;using System.Windows.Forms;using System.Drawing.Imaging;namespace MifFileType{public class MifFileType : FileType{public MifFileType(): base(&quot;MIF Files&quot;, FileTypeFlags.SupportsLoading | FileTypeFlags.SupportsLayers, new String[] { &quot;.mif&quot; }){}protected override Document OnLoad(Stream input){if (input.Length &lt; 20){MessageBox.Show(&quot;Invalid MIF File&quot;, &quot;UMU Corporation - MifFileTypePlugIn&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);Bitmap b = new Bitmap(800, 600);return Document.FromImage(b);}try{BinaryReader br = new BinaryReader(input);int MifVersion = br.ReadInt32();int FrameWidth = br.ReadInt32();int FrameHeight = br.ReadInt32();int MifType = br.ReadInt32();int FrameCount = br.ReadInt32();int ImageWidth = FrameWidth;int ImageHeight = FrameHeight * FrameCount;bool Valid = true;long Prefix;if (MifType == 3){Prefix = 20;}else if (MifType == 7){Prefix = 20 + 4 * FrameCount;}else{MessageBox.Show(&quot;Invalid MIF File&quot;, &quot;UMU Corporation - MifFileTypePlugIn&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);Bitmap b = new Bitmap(800, 600);return Document.FromImage(b);}if (MifVersion == 0){if (Prefix + ImageWidth * ImageHeight * 3 != input.Length){Valid = false;}}else if (MifVersion == 1){if (Prefix + ImageWidth * ImageHeight * 3 &gt; input.Length){Valid = false;}}if (!Valid){MessageBox.Show(&quot;Invalid MIF File&quot;, &quot;UMU Corporation - MifFileTypePlugIn&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);Bitmap b = new Bitmap(800, 600);return Document.FromImage(b);}Bitmap bmp = new Bitmap(ImageWidth, ImageHeight);for (int CurrentFrame = 0; CurrentFrame &lt; FrameCount; ++CurrentFrame){if (MifType == 7){input.Seek(4, SeekOrigin.Current);}UInt16[] rgb16 = new UInt16[FrameWidth * FrameHeight];for (int i = 0; i &lt; FrameHeight * FrameWidth; ++i){rgb16[i] = br.ReadUInt16();}Byte[] a8 = new Byte[FrameWidth * FrameHeight];for (int i = 0; i &lt; FrameHeight * FrameWidth; ++i){a8[i] = br.ReadByte();}for (int y = 0; y &lt; FrameHeight; ++y){for (int x = 0; x &lt; FrameWidth; ++x){int a = a8[x + y * FrameWidth];int r = (rgb16[x + y * FrameWidth] &amp; 0xF800) &gt;&gt; 8;int g = (rgb16[x + y * FrameWidth] &amp; 0x07E0) &gt;&gt; 3;int b = (rgb16[x + y * FrameWidth] &amp; 0x001F) &lt;&lt; 3;if (a == 32){a = 255;}else if (a &gt; 0){a &lt;&lt;= 3;}bmp.SetPixel(x, FrameHeight * CurrentFrame + y, Color.FromArgb(a, r, g, b));}}}br.Close();return Document.FromImage(bmp);}catch (Exception ex){MessageBox.Show(ex.Message, &quot;UMU Corporation - MifFileTypePlugIn&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);Bitmap bmp = new Bitmap(800, 600);//Document doc = Document.FromImage(bmp);//doc.Tag = &quot;UMU Corporation - MifFileTypePlugIn&quot;;//return doc;return Document.FromImage(bmp);}}}public class MifFileTypeFactory : IFileTypeFactory{public FileType[] GetFileTypeInstances(){return new FileType[] { new MifFileType() };}}}  &nbsp;</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_90115" href="https://my.oschina.net/umu618/blog/90115">图像格式转换之 Jpeg2Jxr</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-11-18 15:40:25</div>
                <div class='catalog'>分类：.NET</div>
                                                                            </div>
            <div class='content'>　　为什么转？因为 JXR 格式在同等质量的情况下，存储空间比 JPEG 节约了 45-50%。　　　　　　　　　   　　之前在《从 Windows 8 新功能推理某产品的八哥》提到过现在手机上的省流量 App，其原理就是压缩图片，但为了提高效果，这个压缩基本都是有损的，流量减少了，但是图片质量下降了，有的下降可以忍受，有的则令人发指！比如，长微博，文字转图片，这种图片线条分明，相邻像素值对比可能很大（黑白分明），这类图片采用高压缩比的 JPEG 压缩后，图片质量往往很差。   　　再举个例子：QR 码图片，您可以做一下试验，为了说明 JPEG 不适合存储线条型图片，哥采用一张蛋疼的 1290*1290 像素的 QR 码图片，保存为 JPEG 大小是 4.76MB，但保存为 PNG 格式时只有 52.4KB，请注意单位，前者是后者大小的将近 100 倍！！   　　大家可能比较少关注 WP，也许您没听过 DataSense，简单地说，它就是微软做的节省流量的 App。号称可以节约 45% 的流量，这么大的压缩率，除了优化 HTML 相关的文本之外，对图片的压缩肯定是必须的！虽然至今，UMU 也没有亲眼看过这个 App，但根据一些蛛丝马迹，可以推测 DataSense 可能使用了 JPEG XR 格式来转化其他格式的图片。   　　JPEG XR 虽然已经成为一种标准，但目前依然只有微软支持，所以，如果您想把这个技术应用到 iOS、Android 的节省流量 App 中，那很抱歉，此路不通（这也是 UMU 敢把此文发布出来的原因，我们公司对有产品使用的技术都要求严格保密！）   　　根据实测，IE9@PC、IE10@PC、IE10@WP8 都是支持 JXR 格式的。下面是用 C++/CLI 写的很简单的一个格式转化程序：  using namespace System;using namespace System::IO;using namespace System::Windows::Media;using namespace System::Windows::Media::Imaging;bool ConvertToJxr(System::String^ source_name){    //try {        Stream^ stream = gcnew FileStream(source_name, FileMode::Open, FileAccess::Read, FileShare::Read);        BitmapDecoder^ jpeg_decoder =  BitmapDecoder::Create(stream, BitmapCreateOptions::PreservePixelFormat, BitmapCacheOption::None);        //JpegBitmapDecoder^ jpeg_decoder = gcnew JpegBitmapDecoder(gcnew Uri(source_name, UriKind::RelativeOrAbsolute), BitmapCreateOptions::PreservePixelFormat, BitmapCacheOption::None);        //Console::WriteLine(L&quot;Author: `{0}'&quot;, jpeg_decoder-&gt;Metadata-&gt;Title);        FileStream^ jxr_file_stream = gcnew FileStream(source_name + L&quot;.jxr&quot;, FileMode::Create);        WmpBitmapEncoder^ jxr_encoder = gcnew WmpBitmapEncoder;        //BitmapMetadata^ metadata = gcnew BitmapMetadata(L&quot;wmphoto&quot;);                for each (BitmapFrame ^ frame in jpeg_decoder-&gt;Frames) {            jxr_encoder-&gt;Frames-&gt;Add(BitmapFrame::Create(frame, jpeg_decoder-&gt;Thumbnail, (BitmapMetadata^)frame-&gt;Metadata, jpeg_decoder-&gt;ColorContexts));        }        //jxr_encoder-&gt;Metadata = metadata;        jxr_encoder-&gt;Save(jxr_file_stream);    //} catch (...) {    //    return false;    //}    return true;}int main(array&lt;System::String ^&gt; ^args){    for each (auto arg in args) {        if (File::Exists(arg)) {            if (ConvertToJxr(arg)) {                Console::WriteLine(L&quot;Converted: `{0}'&quot;, arg);            }        } else {            Console::WriteLine(L&quot;NOT Exists: `{0}'&quot;, arg);        }    }    return 0;}  　　　文末是一些搜索到的关于 JPEG XR 的资料，可供参考：&nbsp;     http://jpeg.org/newsrel26.html    JPEG XR (ISO/IEC 29199-2) is now an International Standard and also an ITU-T Recommendation (T.832).    JPEG XR（旧称 HD Photo 及 Windows Media Photo）是一种连续色调静止图像压缩算法和文件格式，由Microsoft开发，属于Windows Media家族的一部分。它支持有损数据压缩以及无损数据压缩，并且是微软的XPS文档的首选图像格式。目前支持的软件包括.NET Framework（3.0 or newer），Windows Vista/Windows 7、Internet Explorer 9，Flashplayer 11等。    JPEG XR（微软HD Photo格式）2009 年，成为 ITU-T 推荐的国际标准（ISO/IEC 29199-2）。JPEG XR 的标准化确保数码相机、打印机、显示器和软件公司能够在开发其新产品的时候兼容互通。其核心技术由微软核心媒体开发团队开发完成，针对当前和将来的数字图像发展需求以提供了许多新的优势和特点。    在 Vista 操作系统中已经支持了这种新的文件格式，JPEG XR 相比其它技术更有优势，其中包括更好的压缩技术，以一半的文件大小保存与 JPEG 相同质量的图像，或以相同大小的文件保存质量相当于 JPEG 两倍的图像。JPEG 组织还对微软开放与 JPEG XR 相关的专利的决策表示了赞扬，称微软免许可费政策将有助于JPEG推动 JPEG XR 普及，有助于确保它能够被更多的用户所采用。JPEG 组织还鼓励其它公司向微软学习。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_90192" href="https://my.oschina.net/umu618/blog/90192">用树莓派 + USB 无线网卡做了一个蛋疼的 AP Client</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-11-18 23:21:09</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　本文的重点是“蛋疼”，所以别告诉 UMU：“把 USB 无线网卡直接插在电脑上就可以了，做这个干什么？！”   　　解释一下 UMU 的困境吧！UMU 有个设备要上网，蛋疼的是这个设备特么的只有 RJ45 接口，而且它放置的位置离路由器很远，也不爱拉线……这不是最惨的！UMU 买了一个支持 AP Client 的无线路由器（TP-Link TL-WR800N）尼玛每次把这个 AP Client 断电时，提供网络的主路由器都会被这个 AP Client 搞死掉，原因未知……您知道 UMU 的痛苦了吧！   　　还没有树莓派的时候，哥用笔记本上的 Windows 的 ICS 功能给它提供网络，当然这方法很不好，于是有了现在的方案。   　　仔细查看了树莓派支持的 USB WiFi Adapters 列表，挑选了 TP-LINK TL-WN823N（RT8192CU 芯片），这个在 Raspbian 上是 Work out-of-box。   　　硬件准备好后，第一步，配置 Wifi，连上主路由器，假定，此步将 wlan0 的 IP 配置为 192.168.1.2，/etc/network/interfaces 的内容如下：  auto loiface lo inet loopbackiface eth0 inet staticaddress 192.168.24.51netmask 255.255.255.0auto wlan0iface wlan0 inet staticaddress 192.168.1.2netmask 255.255.255.0gateway 192.168.1.1wpa-conf /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp  　　192.168.24.51 这个 IP 可以改为别的，UMU 习惯用这个当网关地址。/etc/wpa_supplicant/wpa_supplicant.conf 的内容这里就忽略了，参考 http://elinux.org/RPi_Peripherals#Wireless:_TP-Link_TL-WN722N_USB_wireless_adapter_.28Debian_6.29。设置完，ifdown wlan0 再 ifup wlan0，看看 USB 无线网卡的指示灯应该闪起来了……   　　第二步，配置 RJ45 网口的 NAT。首先，修改 /etc/sysctl.conf，增加以下两行：  net.ipv4.ip_forward=1net.ipv4.conf.all.accept_source_route = 1  　　运行 echo 1 &gt; /proc/sys/net/ipv4/ip_forward 和 iptables -t nat -A POSTROUTING -s&nbsp;192.168.24.0/24 -o&nbsp;wlan0 -j SNAT --to 192.168.1.2，并将这条命令写到 /etc/rc.local 中的 exit 前。   　　最后，reboot 一下试试。可以用网线把 PC 和树莓派连起来，PC 的网卡设为 24 段地址，网关 192.168.24.51，试一下 PC 通过树莓派的网口上网吧！</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_93199" href="https://my.oschina.net/umu618/blog/93199">拯救 TL-WR941N V4.1 路由器</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-11-30 20:15:30</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>死因：在官方 ROM 上 刷不了 Tomato，试着刷了 DD-WRT 后，再刷 Tomato，结果刷完 213 了……   TTL 线拯救，网络是强大的，关键字：WR941N 短路 C278 电容   本文只为发几张图，如果有人不幸和 UMU 一样壮烈地撸死了这款路由器，可以参考之。    &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_95163" href="https://my.oschina.net/umu618/blog/95163">开发 LSP 遇到的蛋疼问题</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-12-11 18:16:00</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　今天发生了一个莫名其妙的问题，导致浪费了一个早上的时间排查问题。   　　测试 LSP 期间，已经反注册它，netsh winsock reset 加重启了好几次……依然有程序加载它，用 Process Explorer 查了一下是：IpOverUsbSvc.exe 和 daemonu.exe，后来把 LSP 文件删掉，再重启，这时候当然无法加载了，可是 UMU 又想重现一下这个莫名其妙的问题，结果一个早上没了，无法重现，尼玛的……   15:38 2012/12/25 补充   　　今天这个现象又出现了，再手动重启这两个服务后，不再加载 LSP 了。它们对应的服务名是：IpOverUsbSvc 和 nvUpdatusService。这说明这两个服务很可能每次重启机器时都没有正常关闭，系统提供了某种机制让他们在下一次重启后快速恢复了运行现场（保留了有 LSP 注册时的环境），尼玛的……</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_98025" href="https://my.oschina.net/umu618/blog/98025">XP 下 Edit 控件透明字体时的 Bug</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-12-25 10:06:29</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>前提：XP 系统，程序使用了 Manifest 指定使用 Microsoft.Windows.Common-Controls   现象：Edit 控件处理 WM_CTLCOLOREDIT 改变颜色，问题出在 SetBkMode 设置透明后，控件删除字符时无法立刻刷新，即会残留。   解决方法1：自残，别用 Microsoft.Windows.Common-Controls 了……删除类似下列的代码  #if defined _M_IX86    #pragma comment(linker, &quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;)#elif defined _M_IA64    #pragma comment(linker, &quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='ia64' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;)#elif defined _M_X64    #pragma comment(linker, &quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;)#else    #pragma comment(linker, &quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;)#endif  解决方法2：放弃“透明”采用“伪透明”——如果您的背景是纯色，用 SetBkColor 就行了。   解决方法3：检测到 XP 时，WM_CTLCOLOREDIT 返回画刷前，自己用 FillRect/Rectangle 涂一下……或者发一个 WM_ERASEBKGND，当然这个做法的前提是 WM_ERASEBKGND 的处理就是自己涂一下，如果就一句 return TRUE 那是等于啥也没干。     &nbsp;   参考：  同样悲剧的一个描述： http://zhidao.baidu.com/question/9749770.html  &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_98039" href="https://my.oschina.net/umu618/blog/98039">判断系统是不是 XP</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-12-25 11:16:06</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>XP 下 Edit 控件透明字体时的 Bug   很简单的问题，蛋似，要考虑到“兼容性”   如果系统是 Vista、Win7、8、9、10，则他们都有兼容 XP 的模式，GetVersion/GetVersionEx 都会被欺骗，所以，这种情况需要的是：VerifyVersionInfo  http://msdn.microsoft.com/en-us/library/ms725492(v=vs.85).aspx  &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_108520" href="https://my.oschina.net/umu618/blog/108520">天翼宽带智能提速</a></h2>
            <div class='outline'>
                <div class='date'>时间：2011-12-13 00:00:00</div>
                <div class='catalog'>分类：业余作品</div>
                                                                            </div>
            <div class='content'>2011-12-13 17:03 发布于百度空间，最近百度删除了 UMU 高中时代珍贵的记录，所以 UMU 正在去百度化，转移到此处。      天翼宽带智能提速   　　福建省的中国电信天翼宽带（家庭&nbsp;ADSL&nbsp;网络）用户每月可免费使用&nbsp;5&nbsp;小时智能提速，这是一个很给力的东西，一般&nbsp;ADSL&nbsp;下行速率是&nbsp;4Mbps，最高可以提到&nbsp;20Mbps，看高清电影、下载各种&nbsp;X&nbsp;片毫无鸭梨。详见：http://ts.oooxm.com/   　　蛋似！作为一名舍不得多掏钱的天朝子民，怎么合理地利用这&nbsp;5&nbsp;小时免费提速时间，成为一个有点鸭梨的问题。UMU&nbsp;的这个小工具就是为了解决这个问题而“蛋生”。   　　简单地说就是程序帮您监控网络使用情况，流量跑高了就提速，流量低下来就自动停止提速。另外，官方的提速方式是通过网页的形式，UMU&nbsp;的程序可以在程序界面上直接提速和停止提速。   　　下载：   v1.1   http://pan.baidu.com/share/link?shareid=90607&amp;uk=3607387813/   　　如果您无法下载，请&nbsp;Email&nbsp;我，umu618[AT]189[DOT]cn。    　　下面介绍原理：    &nbsp;   1、流量，API：GetIfEntry、GetIfEntry2   2、SOAP 协议，UMU 用的是 ATL SOAP @ ATL Server，您也可以试试更大型的 gSOAP。   3、原理就是把本来就有的带宽还给我们，原来的 4M 其实是故意限制的……提速的手段除了电信官方分方法之外，还有 OpenWRT 上的“多拨”方案，同时拨号N次，可能拨通，一个4M，如果拨上15个就有60M了……   2013-05-09，这个软件已经有 ARM 版本：http://my.oschina.net/umu618/blog/129428   &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_114156" href="https://my.oschina.net/umu618/blog/114156">协议加速的三个时代</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-03-16 15:51:08</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　这里要说的是基于反向代理＋缓存的加速。位于客户端和服务端之间的加速系统，理解某些协议，并对这些协议进行处理，使客户端不需要做任何改动的前提下，其请求被重定向到更“近”的“代理服务器”上。   普通时代   　　主要处理公开的协议，最明显的例子是 HTTP 下载，加速系统理解 HTTP 协议，当收到 GET 请求时，伪造 302 等跳转回应，使客户端改向加速系统提供的“代理服务器”下载。   　　当一个域名只用于 HTTP 服务时，还可以对这个域名做文章……DNS 协议也是公开的。   文艺时代   　　各种下载器、视频应用开始了私有协议……so，逆向就必不可少了，这个时代加速服务提供商必须有一定开发实力了，不能再撸一些开源代码组合一下就了事。   二逼时代  　　某些下载器的公司出于各种原因不希望别人假扮自己的“服务器”，于是做出了艰难的决定，下载协议要用非对称算法加密，这样一来，即使那些逆向高手把整个下载器客户端都逆向了，那也只是做出一个客户端，无法扮演服务端，于是乎……加速服务公司都 2B 了，要私钥吗？分点钱吧！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_117397" href="https://my.oschina.net/umu618/blog/117397">枚举物理网卡</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-03-25 15:25:41</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>　　其实目的是获取靠谱的 MAC 地址，但这个任务真蛋疼！不信您看看搜索出来的垃圾……　　神马 GetAdaptersInfo、GetIfEntry、GetAdaptersAddresses、NetWkstaTransportEnum，还有读取注册表 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards。这些都会枚举到虚拟网卡，给您举个例子“VirtualBox Host-Only Ethernet Adapter”，读取神马 NetCfgInstanceId、MediaSubType，都不靠谱，没有平台移植性！　　用 Setup API 枚举 Interface，匹配 PCI 和 USB 类型是比较靠谱的。　　蛋似，虚拟机的网卡也是虚拟的，为了方便在虚拟机测试，您要注意放开一些特例……很抱歉，代码没有，自己搜吧，关键字：SetupDiGetDeviceInterfaceDetail、OID_802_3_PERMANENT_ADDRESS。　　给个蛋碎的例子：\\.\pci#ven_10ec&amp;dev_8168&amp;subsys_050e1028&amp;rev_06#4&amp;224db6dd&amp;0&amp;00e5#{ad498944-762f-11d0-8dcb-00c04fc3358c}\{4cc0ea76-88b7-40e1-8b4b-6339f8dd49bf} 可以简称为 \\.\{4cc0ea76-88b7-40e1-8b4b-6339f8dd49bf} 或者 \\.\Global\{4cc0ea76-88b7-40e1-8b4b-6339f8dd49bf}。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_117635" href="https://my.oschina.net/umu618/blog/117635">快游为什么是现在这样</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-03-26 11:59:43</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　首先，叫“智能加速2012”有两个槽点，某个合作方不让“快游”字样出现，所以叫“智能加速”，2012 是因为这一年，快游大众版被公司战略性调整给干掉了，这是个悲剧的开始，整个团队基本都走掉或者转岗。详见：http://blog.sina.com.cn/kuaiyou2012   　　所以，为什么现在的快游是“没错”风格的界面就不难理解：理性因素——快游的设计、开发只有 UMU 一人，连美工都要包，所以如果继续以前的风格，UMU 要把大部分时间贡献于作图，这是相当悲剧的；感性因素——UMU 很喜欢简单、干净的东西，没错风格正好符合。      　　出错时，标题栏出现版本号，状态栏出现“各种”简单的解释，右上角出现“各种”帮助链接：      　　主界面，某些定制版本需要登陆才能开启加速，这由配置决定，这时左上角会出现“登陆”按钮。      　　这里的广告栏，目前是免费帮 Windows Phone、Surface 打广告，因为 UMU 喜欢这两这个东西。       　　更多用户选项和用户引导，甚至出现了以下两个辅助功能：      　　所有图标都是用 Metro Studio + Paint.NET 做的，因为 UMU 是程序员，不懂那些高端的美工工具……开发平台：VS2012+WTL+DUI 库。  　　官网 http://www.94kuai.com/ 挂掉期间转移“移动体验版”到 http://kuaiyou.duapp.com/，这个版本是为了让用户帮 UMU 做更广泛的测试，不然 UMU 测自己的程序，恐怕容易吐，而且还吐得不干净……</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_117644" href="https://my.oschina.net/umu618/blog/117644">快游简史</a></h2>
            <div class='outline'>
                <div class='date'>时间：2012-05-20 00:00:00</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>http://t.qq.com/Kuaiyou2012   0、初尝阶段——技术为导向   　　为了从技术上超越对手，走自主研发道路，从应用层到驱动层，几乎把 Windows 平台上所有能拦截、过滤网络数据的方案都试过一遍。   　　其中主要的技术方案：TDI 驱动、NDIS IMD、LSP（IFS LSP 和 Non-IFS LSP 都有用过）。   　　有出产品的一个方案是 NDIS IMD，NT6（Vista+ 系统）上是 NDIS Filter。这个大方向上，又有两个小方案：纯的 NDIS&nbsp;驱动；接合 LSP 收集游戏 IP 的方案。但是最终因为驱动频繁导致蓝屏，被合作方无情地抛弃……   　　不难发现，其实一开始就走错路了，开始产品化的时间是 2008 年，市面上还没多少游戏加速器，最突出的一个就是迅游，他们用的是&nbsp;VPN+收集路由表的方式，使用的都是现有的成熟技术；而自主研发的驱动要做稳定需要经过很长时间的考验，产品压力下，我们的时间不够……   1、失败重组阶段——开始以产品为导向   　　尝试了 VPN 的路线，想很快做出来，OpenVPN 的积累不足没法很快搞定，系统自带的 PPTP、L2TP 等 VPN，可以很快做出来，但是遇到机房限制，电信的机房不让我们的服务器架设 VPN……最后只能在部分小运营商内使用此方案。   　　后来终于重新启用了 LSP 的方案。这个方案原来被弃用原因是一开始使用的是自主研发的代理协议，出了不少问题，并且 LSP&nbsp;确实也是个很麻烦的东西，安装后容易断网，还会与其它 LSP 冲突……后来代理协议改为公开的 Socks5 协议，服务器端的开发省掉了，全心全力解决 LSP  的问题。总算慢慢看到希望。   2、缓慢发展阶段——以产品和用户为导向   　　由于一直招不到好的开发人员，只能边培养边做事，开发效率不是很高，经常犯错，导致用户投诉。但是整体上一直在收集用户问题，一直在努力解决它们。尤其是核心的&nbsp;LSP 实现、安装和代理服务程序，参考来了很多同类产品，后来锁定了微软的 Firewall Client for ISA，把&nbsp; LSP 做成 IFS&nbsp;LSP，使用类似 BSP 的安装方式，这是兼容性最好的方式了。代理服务程序由服务型 COM 对象改为一个普通进程，使用文件映射通信。界面也重新设计，准备推出快游&nbsp;2012 版。这时候，注册用户是 60 万，在线用户每天平均&nbsp;1.9 万。   3、快速死亡阶段——以商业为导向   　　就在希望满怀，团队兴致最高，暗黑&nbsp;3 正要引发游戏界又一轮高潮的时候，公司突然不打算做了……目前，为了推广“马头流量”http://www.matocloud.com/，尚能维持运营一段时间。   　　快游 2012，又称快游末日版，果然成为末日了！咳咳~一切都是因为钱嘛，可以理解……</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_117854" href="https://my.oschina.net/umu618/blog/117854">开发 LSP 遇到的蛋疼问题 - 解释原理篇</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-03-26 23:24:30</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　此前，UMU 在《开发 LSP 遇到的蛋疼问题》http://my.oschina.net/umu618/blog/95163，对那个蛋疼的问题，做出了这样的推测：系统提供了某种机制让系统服务在下一次重启后快速恢复了运行现场！现在终于明白是怎么回事了，请看下文：     在安装 Win8 后，很多人都体验到了其开关机惊人的速度，尤其是开机速度，相比 Win7 之下，它提升的不止是一点半点。在某些超极本和配备了 SSD 的机器上，其开关机速度可以在数秒以内。例如 Surface Pro，其实测系统引导速度为2秒，从启动到自动登录到开始屏幕只要6秒。    究竟是什么技术提升了 Win8 的开关机速度呢？如果要用最简单的一句话概括，那应该是&quot;系统会话休眠&quot;，或者更简单的，&quot;混合式关机&quot;。    在 以往的 Windows OS 中，典型的关机顺序为：    1. 单击&quot;关机&quot;。    2. Windows 广播运行应用程序关机信息，让应用程序可以保存数据和设置。应用程序也可以要求一些额外的时间以结束其当前工作。    3. Windows 为每个登录用户关闭用户会话。    4. Windows 向服务发送关机信息，通知已开始关机，接着关闭服务。如果服务未响应，系统将强制关闭。    5. Windows 向设备广播信息，示意设备进行关闭。    6. Windows 关闭系统会话（也称为&quot;会话 0&quot;）。    7. Windows 刷新系统驱动器待决数据，以确保完全保存。    8. Windows 通过 ACPI 界面向系统发送信号以给计算机断电。    看着以上的典型关机步骤，你是不是也有想到一些步骤对应的屏幕上的 UI 表现呢~    再来看看 Windows 8 采用的混合式关机主要步骤：    1. 单击&quot;关机&quot;。    2. Windows 广播运行应用程序关机信息，让应用程序可以保存数据和设置。应用程序也可以要求取得一些额外的时间以结束其当前工作。    3. Windows 为每个登录用户关闭用户会话。    4. 系统会话休眠，并掉电。    可见，Windows 8 只关闭用户会话而不像以前那样完全关闭计算机。此时， Windows 不再等待并结束系统服务和关闭会话 0，而是让其进入休眠。这种关闭用户会话+休眠系统服务和系统会话的做法，被称为&quot;混合式关机&quot;，也就不难理解了。    或者说得通俗点，就好比你之前打扫卫生时，需要先组装专业的拖布，组装好了以后，才能开始打扫卫生。而现在，你可以拿起拖布直接开始打扫，因为你上次打扫完之后，并没有将拖布这一工具像以往那样拆卸下来收好。    开机在结构上是关机的逆过程，所以有了混合式关机，开机自然也就快了。但是，除了 RAID 卡外，一般硬盘的读取速度会比写入速度略快，加上关机的时候，系统会通知并等待应用程序退出，所以从感官上，开机过程会比关机过程显得要快一些。    　　关机关得快果然是有风险的！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_119745" href="https://my.oschina.net/umu618/blog/119745">程序员心法三则</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-04-04 00:44:11</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　本文不是介绍奇技淫巧，甚至本质上并不是技术，而是态度，心法。   １、抓住问题的本质，在源头解决问题   　　简单地说，A 有八哥，B 依赖 A，所以导致依赖 B 的 C 出问题，您会通过修改 B 来解决问题吗？正常人都知道要先解决 A 的八哥，蛋似，稍微复杂、含蓄点的问题就有人迷糊了：   　　一个浮动小窗体，不希望在任务栏上出现标签。   　　UMU 见过有人使用了 ITaskbarList 对象的 DeleteTab 方法来删掉任务栏上的标签，很高端的做法。蛋似，不够本质，我们要的是不让它出现，而不是出现后擦掉……很早以前，explorer.exe 挂掉后，任务栏通知区域的 QQ 图标就消失了，因为当时 QQ 没有处理任务栏重建的通知消息 TaskbarCreated，重新添加图标。前面说的方法，有同样的问题，explorer.exe 重启后，标签又会出现，还要再删除一次。   　　正确的主流做法有两个，看情况采用：(1)、WS_EX_TOOLWINDOW；(2)、指定一个隐藏窗体为自己的拥有者。   　　另一个脱裤子放屁的例子：获得一个文本文件大小，然后 new 一个够大的 char 数组 p，把内容读到 p 上，最后 ::std::string str = p; delete[] p;，这个见太多次了，懒得喷了，::std::string 有 resize 方法，可以直接分配，不需要 new 一个临时数组，再 delete……   　　《判断系统是不是 XP》http://my.oschina.net/umu618/blog/98039，也包含了这一哲学，表面上看有好多函数可以获得系统信息，但要明白他们的本质其实有差别，不是都可以混用。   2、要有远见，没有？至少不要不见棺材不落泪！   　　Y2K 已经过去了，但还有一个 Y2K38，又称 Unix Millennium Bug，历史原因 Unix 时间戳是一个 32 位整数，记录从 1970 年 01 月 01 日开始的秒数，它所能保存的最大时间长度大概是 68.1 年，2038 年 1 月 19 日 03:14:07 之后。 &nbsp; &nbsp;&nbsp;&nbsp; 以前硬盘容量小，也不看高清，很多代码都认为文件大小用 32 位表示就够了，结果后来出现很多 ISO、高清电影，都超过 4G……还见过有人采集流量用 32 位整形表示，时间跑久了就溢出了。   &nbsp;&nbsp;&nbsp; 远见未必人人都有，退一步说，UMU 敢保证，有很多人即使知道 32 位不够用，还是继续用着，明知道 IPv6 已经出现了很久，还是各种硬编码，认为 IP 地址一定是 IPv4 的地址。态度问题！   3、不要姑息养奸   &nbsp;&nbsp;&nbsp; 遇到不合理的情况，UMU 认为应该给力地告诉该知道的人。比如，函数不希望入参是某指，可是调用者偏偏就输入了那个值，怎么办？打印调试信息？不够给力，容易被忽视，应该中断一下，告诉开发者。   &nbsp;&nbsp;&nbsp; 配置文件字段被改错，怎么办？如果这个文件是技术人员维护的，应该抛出异常，死给修改配置文件的人看；如果是一般的最终用户，那应该弹出界面，友好提示哪里、怎么错了。   &nbsp;&nbsp;&nbsp; 早期，很多程序员为了避免头文件被重复包含，就用了以下代码：  #ifndef XXX#define XXX// 各种语句#endif  &nbsp;   &nbsp;&nbsp;&nbsp; 后来，大家喜欢用 #pragma once，省事，又不容易漏掉最后的 #endif。但是这样做之后会……姑息养奸，对严谨的人来说，重复包含是不应该的！所以应该这样：  #ifdef XXX#error &quot;您不严谨了！&quot;#endif#define XXX// 各种语句  &nbsp;&nbsp;&nbsp; 有重复包含立刻告警，而且都是集中在开头，不存在漏掉 #endif 的问题。   &nbsp;&nbsp;&nbsp; 态度问题！这里只是举几个简单的例子~</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_123553" href="https://my.oschina.net/umu618/blog/123553">解析一下 Windows 的快捷方式居然这么难……</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-04-18 10:35:45</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>　　首先，当然是 MSDN 一下 IShellLink 这个 COM 接口，照着写一下，然后测试。郁闷的事情开始了！   　　IShellLink 对象无法正确解析 MSI 创建的新型快捷方式，所以要用 MsiGetShortcutTarget + MsiGetComponentPath 先尝试获得，失败了才用 IShellLink。   　　继续测试大量快捷方式后，就会发现一个惨无人道的问题：当自己是 x86 程序时，读取的快捷方式如果指向的是 Program Files 下的任何文件或者文件夹，都会被强制解析为 Program Files (x86)，好智能啊！！   　　搜一下，发现使用 IShellLink 对象的前提下，无法解决这个问题。无数老外都郁闷！哥开始逆向，发现是 IDL 被读出来时就已经做了转换，所以用 IShellLink::GetIDList + SHGetPathFromIDList 也是浪费力气。   　　最后无奈了，如果发现自己在 WOW64 下运行就直接自己解析快捷方式了……参考链接如下：   http://www.vckbase.com/index.php/wv/1132 http://www.codeproject.com/Articles/24001/Workaround-for-IShellLink-GetPath http://biancheng.dnbcw.info/1000wen/447642.html   &nbsp;</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_126213" href="https://my.oschina.net/umu618/blog/126213">坑爹的 VS2012 Update 2！居然不支持 XP 了！含解决方案！</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-04-28 14:58:39</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　最近 VS2012 升级了 Update 2，结果导致编译出来的程序不支持 XP 了，详情：http://social.msdn.microsoft.com/Forums/en-US/visualstudiogeneral/thread/f0477c9f-8a2c-4e6b-9f5a-cd2469e216c4  　　经过多个项目对比，发现不是全部不支持，然后对比了这些项目后发现有一个 link 选项不一样，有 /OPT:REF 的就支持 XP，目前为止这个方法挺管用，比上面链接里老外提到的方法好用多了！</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_129428" href="https://my.oschina.net/umu618/blog/129428">开发 Windows RT 桌面应用（来自 Surface RT）</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-05-09 22:37:39</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>首先，不管大家怎么喷 Windows RT，UMU 是看好它的，这篇文章就是用 Surface RT 写的。如果说有什么不爽的…请看 PPI 对比：Surface RT ＝ sqrt(1366^2+768^2)/10.6=147.8，XPS 15 ＝ sqrt(1920^2+1080^2)/15.6=141.2，居然才比 XPS 15 高了一小点！还有后摄像头成像质量太一般了。您可能发现了，UMU 说的缺点都是硬件上的。 再来要说的是，微软的自残行为。UMU 用过 iOS、Android 平板，甚至见过有人用 XP 平板，但相信，论系统本身 Windows RT 是最强大的。不过微软为了战略目标，把 RT 强大的一面给锁起来了。对开发人员来说，这锁表现在以下几点： 1、系统本身不允许运行没有微软签名的 EXE； 2、VS2012 默认无法编译 ARM 程序； 3、VS2012 自带的 ARM lib 缺失。 下面就是简单介绍一下如何突破这三个封锁： 1、解锁签名限制 RT Jailbreak ToolBy Netham45, Version 1.20 http://forum.xda-developers.com/showthread.php?t=2092158  另外，有很多开源软件已经移植，在开发自己的程序之前，可以先试试，Desktop apps ported to Windows RT：http://forum.xda-developers.com/showthread.php?t=2092348  2、开启 VS2012 的 ARM 支持 来自&nbsp;http://stackoverflow.com/questions/11151474/can-arm-desktop-programs-be-built-using-visual-studio-2012 的答案 You can edit the file: C:\Program&nbsp;Files&nbsp;(x86)\MSBuild\Microsoft.Cpp\v4.0\V110\Platforms\ARM\Microsoft.Cpp.ARM.Common.props 对 VS2013 路径是： C:\Program&nbsp;Files&nbsp;(x86)\MSBuild\Microsoft.Cpp\v4.0\V120\Platforms\ARM\Platform.Common.props In the&lt;PropertyGroup&gt;section add the line: &lt;WindowsSDKDesktopARMSupport&gt;true&lt;/WindowsSDKDesktopARMSupport&gt; before&lt;/PropertyGroup&gt; And that's all, you can build ARM desktop apps with VS2012. 某些工程需要强制定义 _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 才可以。 3、获取更多的 ARM libs 开源工具应运而生：https://github.com/peterdn/dll2lib  然后，炫耀一下，UMU 已经把自己的一个小作品“天翼宽带智能提速”（http://my.oschina.net/umu618/blog/108520）移植成功了，这个程序比较小，一两个小时从解锁到移植开发全部搞定。 最后，如果程序是 .NET 4.x 写的，是可以直接跑在 RT 上的，所以为了省力气，也许应该考虑多用 .NET。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_133901" href="https://my.oschina.net/umu618/blog/133901">[UMU WSH 教程](44) WII 应用实例 - 查找重复文件</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-05-28 11:53:13</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>[UMU WSH 教程](43) WIA 应用实例 - 批量转换图片格式   [UMU WSH 教程](42) FSO 应用实例 - 批量删除文件   UMU WSH 教程代码下载：http://sdrv.ms/ZpPPaS   UMU WSH Git：http://git.oschina.net/umu618/umu-wsh   　　数据经常 in-in-out-out 难免产生重复，比如上次 UMU 在 Surface RT 上导入 iPhone4S 和 iPhone5 的照片时发生的悲剧：    把 iPhone 4S 的照片导到 #Surface#，然后刷机去越狱，后来又把 iPhone 5 的照片也导进来，没料到两个 iPhone 的文件夹是一样的名字，于是文件混到了一起，尼玛！里面有不少内容不一样文件名一样的照片，所以选择不覆盖，重新复制 5 的照片到另一个文件夹，但 4S 的文件夹里已经混入了好多 5 的照片！还好 #Surface# 支持 VBScript，哥的去重复文件脚本可以发挥作用了！生产力第一名的平板——其实就是给没有生产力的 iOS 设备打工的，哈！悲剧~   　　本篇要介绍的是使用 Surface RT 支持的 WSH 脚本实现查找重复文件这个任务，其中使用到的三个主要对象：FSO、SD 大家应该知道，WII&nbsp;是 WindowsInstaller.Installer，参考：《[UMU WSH 教程](40) 利用 WindowsInstaller.Installer 对象计算文件 MD5 hash 值》一文，http://hi.baidu.com/umu618/item/0769e3cecd216e3298b4980a   　　先把思路介绍清楚，以便读者使用其它语言实现：1、计算 Hash 的代价是比较高的，而文件大小是很容易获取的，所以应该先利用文件大小来比较文件，只有大小重复的需要计算 Hash；2、空文件都是重复的，不用 Hash 了……3、由于要做成通用程序，所以只做了查找，您可以根据代码，自行添加删除带某些特征的重复文件。代码如下：  ' 44_FindDuplicates.VBS' UMU @ 10:23 2013/05/26' [UMU WSH 教程](44) 查找重复文件Option ExplicitConst APP_TITLE = &quot;UMU.Script.Tools.FindDuplicates&quot;Dim fsoDim wiDim file_name_dictionary, file_size_dictionary, file_size_and_hash_dictionaryDim file_indexDim groupCall Main()Private Sub Main()    Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)    Dim args    Set args = WScript.Arguments    If args.Count = 0 Then        Dim wsh        Dim send_to, copy_to        MsgBox &quot;本程序用来查找重复文件（根据文件内容，非文件名）。&quot; &amp; vbCrLf &amp; _            &quot;请把要处理的文件或文件夹拖放到本程序的图标上！&quot;, _            vbInformation, APP_TITLE        Set wsh = CreateObject( &quot;WScript.Shell&quot; )        send_to = wsh.SpecialFolders(&quot;SendTo&quot;)        copy_to = send_to &amp; &quot;\FindDuplicates.VBE&quot;        If Not fso.FileExists(copy_to) Then            If vbOK = MsgBox(&quot;本程序用来查找重复文件。&quot; &amp; vbCrLf &amp; _                &quot;请把要处理的文件或文件夹拖放到本程序的图标上！&quot; &amp; vbCrLf &amp; vbCrLf &amp; _                &quot;提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。&quot; &amp; vbCrLf &amp; _                &quot;您的 Sendto 目录是 &quot; &amp; send_to &amp; vbCrLf &amp; &quot;按“确定”执行复制操作。&quot;, _                vbOKCancel + vbInformation, APP_TITLE) Then                fso.CopyFile WScript.ScriptFullName, copy_to                If vbYes = MsgBox(&quot;是否查看 Sendto 目录？&quot;, vbQuestion + vbYesNo, APP_TITLE) Then                    wsh.Run &quot;%SystemRoot%\explorer.exe /n, /select,&quot; &amp; copy_to                End If            End If        End If        Set wsh = Nothing        Set args = Nothing        Set fso = Nothing        Exit Sub    End If    Set file_name_dictionary = CreateObject(&quot;Scripting.Dictionary&quot;)    Set file_size_dictionary = CreateObject(&quot;Scripting.Dictionary&quot;)    file_index = 0    Dim ar    For Each ar In args        If fso.FolderExists(ar) Then            Call AddFolder(ar)        ElseIf fso.FileExists(ar) Then            Call AddFile(ar)        End If    Next    Set ar = Nothing    Set args = Nothing    If file_name_dictionary.Count = file_size_dictionary.Count Then        MsgBox &quot;文件总数：&quot; &amp; file_name_dictionary.Count &amp; vbCrLf &amp; _            &quot;没有重复的文件&quot;, vbInformation, &quot;整个世界清静了！&quot;    ElseIf MsgBox(&quot;文件总数：&quot; &amp; file_name_dictionary.Count &amp; vbCrLf &amp; _        &quot;文件大小不重复数：&quot; &amp; file_size_dictionary.Count, vbInformation + vbOkCancel, &quot;按确定继续&quot;) = vbOK Then        Call FindDuplicates()    End If    Set fso = Nothing    Set file_name_dictionary = Nothing    Set file_size_dictionary = Nothing    MsgBox &quot;重复组数：&quot; &amp; group, vbInformation, &quot;整个世界清静了！&quot;End SubPrivate Sub AddFolder(ByVal folder_path)    'On Error Resume Next    Dim rfd, fs, f, fds, fd    Set rfd = fso.GetFolder(folder_path)    Set fs = rfd.Files    For Each f In fs        Call AddFileWithSize(f.Path, f.Size)    Next    Set fds = rfd.SubFolders    For Each fd In fds        Call AddFolder(fd.Path)    NextEnd SubPrivate Sub AddFile(file_path)    'On Error Resume Next    Dim file    Set file = fso.GetFile(file_path)    Call AddFileWithSize(file.Path, file.Size)    Set file = NothingEnd SubPrivate Sub AddFileWithSize(file_path, file_size)    'On Error Resume Next    file_name_dictionary.Add file_index, file_path    If file_size_dictionary.Exists(file_size) Then        file_size_dictionary.Item(file_size) = file_size_dictionary.Item(file_size) &amp; &quot;;&quot; &amp; file_index    Else        file_size_dictionary.Add file_size, file_index    End If    file_index = file_index + 1End SubPrivate Function BigEndianHex(int)    Dim result    Dim b1, b2, b3, b4    result = Right(&quot;0000000&quot; &amp; Hex(int), 8)    b1 = Mid(result, 7, 2)    b2 = Mid(result, 5, 2)    b3 = Mid(result, 3, 2)    b4 = Mid(result, 1, 2)    BigEndianHex = b1 &amp; b2 &amp; b3 &amp; b4End FunctionPrivate Function GetFileHash(file_name)    Dim file_hash    Dim hash_value    Dim i    Set file_hash = wi.FileHash(file_name, 0)    hash_value = &quot;&quot;    For i = 1 To file_hash.FieldCount        hash_value = hash_value &amp; BigEndianHex(file_hash.IntegerData(i))    Next    Set file_hash = Nothing    GetFileHash = hash_valueEnd FunctionPrivate Sub FindDuplicates()    Set wi = CreateObject(&quot;WindowsInstaller.Installer&quot;)    Set file_size_and_hash_dictionary = CreateObject(&quot;Scripting.Dictionary&quot;)    Dim file_size_array    Dim file_name_index_array    Dim ubound_of_file_size_dictionary    ' UMU: dictionary -&gt; 2 arraies, for quick finding    file_size_array = file_size_dictionary.Keys    file_name_index_array = file_size_dictionary.Items    ubound_of_file_size_dictionary = file_size_dictionary.Count - 1    file_size_dictionary.RemoveAll    Dim i    For i = 0 To ubound_of_file_size_dictionary        If InStr(file_name_index_array(i), &quot;;&quot;) &lt;&gt; 0 Then            If file_size_array(i) = 0 Then                ' UMU: empty files are all the same                file_size_and_hash_dictionary.Add 0, file_name_index_array(i)            Else                Dim file_index_array                Dim index                file_index_array = Split(file_name_index_array(i), &quot;;&quot;)                For Each index In file_index_array                    Dim hash                    Dim key                    ' UMU: CLng() is important                    hash = GetFileHash(file_name_dictionary.Item(CLng(index)))                    key = file_size_array(i) &amp; &quot;:&quot; &amp; hash                    If file_size_and_hash_dictionary.Exists(key) Then                        ' UMU: we've got it!                        file_size_and_hash_dictionary.Item(key) = file_size_and_hash_dictionary.Item(key) &amp; &quot;;&quot; &amp; index                    Else                        file_size_and_hash_dictionary.Add key, index                    End If                Next            End If        End If    Next    Erase file_size_array    Erase file_name_index_array    ' UMU: dictionary -&gt; 2 arraies, for quick finding    Dim file_and_hash_array    Dim ubound_of_file_size_and_hash_dictionary    file_and_hash_array = file_size_and_hash_dictionary.Keys    file_name_index_array = file_size_and_hash_dictionary.Items    ubound_of_file_size_and_hash_dictionary = file_size_and_hash_dictionary.Count - 1    file_size_and_hash_dictionary.RemoveAll    Dim file    Dim cd    cd = WScript.ScriptFullName    cd = Left(cd, InStrRev(cd, &quot;\&quot;))    Set file = fso.CreateTextFile(cd &amp; &quot;Duplicates.txt&quot;)    group = 0    For i = 0 To ubound_of_file_size_and_hash_dictionary        If InStr(file_name_index_array(i), &quot;;&quot;) &lt;&gt; 0 Then            group = group + 1            file.WriteLine &quot;// Group &quot; &amp; group &amp; &quot;, &quot; &amp; file_and_hash_array(i)            file_index_array = Split(file_name_index_array(i), &quot;;&quot;)            For Each index In file_index_array                file.WriteLine file_name_dictionary.Item(CLng(index))            Next            file.WriteLine &quot;&quot;        End If    Next    file.Close    Set file = Nothing    Erase file_and_hash_array    Erase file_name_index_array    Set wi = Nothing    Set file_size_and_hash_dictionary = NothingEnd Sub  &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_151098" href="https://my.oschina.net/umu618/blog/151098">加速器是网游的 CDN</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-08-07 23:23:08</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>用 Surface RT 写于&nbsp;22:41 2013/08/07&nbsp;&nbsp;&nbsp;&nbsp;一般热门网站，比如视频网、门户网，都做 CDN，而且基本上来自第三方。这主要是成本问题，自己做成本往往高于直接购买专业 CDN 公司的服务。&nbsp;&nbsp;&nbsp;&nbsp;具有长久的网络应用有视频网、网络游戏、社交类、财经购物类……&nbsp;&nbsp;&nbsp;&nbsp;其中，只要是基于 HTTP 协议的，做 CDN 都没有问题，但网游是比较另类的一种。为了解决网络复杂带来的各种问题，有的游戏把协议架构在 HTTP 上，然后去做 CDN，但很可惜不是所有游戏都可以这么做……另外的这些游戏，不得不在祖国（甚至世界）各地部署一堆的服务器。&nbsp;&nbsp;&nbsp;&nbsp;如果说，所有游戏都可以做“CDN”（这里加引号，因为两者解决的问题并非完全一致，CDN 有大部分作用是资源缓存，而不是代理穿透），那可想而知，游戏厂家肯定愿意购买，因为自己去部署一堆服务器，就好像自己做 CDN 一样，成本基本都更高。&nbsp;&nbsp;&nbsp;&nbsp;但显然，现在的 CDN 无法解决网游问题。目前有一种叫“策略路由引导”的方式，经常被用于网游加速。确切地说，这种加速方式，适用于弱势运营商。比如中国移动（铁通）宽带，游戏服务器在中国电信，于是中国移动就要买第三方的电信线路作为出口……但这种方式，只能用于少量游戏，因为游戏一旦多了，就存在服务器变动的问题，收集 IP 地址会成为很大的问题，稍微不慎，就可能反而导致游戏不能玩，或者引导了不是游戏的流量（第三方线路可能比较贵或者跑太多非游戏流量，导致游戏加速效果下降）。&nbsp;&nbsp;&nbsp;&nbsp;总之，策略路由的方式局限性很大，只能针对局部地区和少量游戏。现在主流的成熟解决方案还是客户端加速器，但由于客户端一般都是找最终用户收费，所以没有形成类似 CDN 这样的 B2B 产业。&nbsp; &nbsp; 另外，从强势运营商对弱势运营商的打击角度来分析，也不难发现，强势运营商更反感策略路由的方式，因为这种方式会让宽带用户觉得这个弱势运营商的质量也不错，而用加速器的话，宽带用户是知道这个弱势运营商的质量不行的，还要用户自己买个加速器辅助。所以策略路由的方式是强势运营商必须打击的，而加速器则是欢迎的。&nbsp;&nbsp;&nbsp;&nbsp;如果说，CDN 很赚钱，那么网游界的“CDN”是不是也应该很赚钱呢？让我们先来看看加速器都有哪几家在做！老大迅游已经号称有&nbsp; 9kw 用户，网易、腾讯、迅雷、百度（http://anquan.baidu.com/bbs/thread-2831-1-1.html）也参与了，盛大已经退出，360 从 2012 年就放声要做。比较贵的四七代理（迅雷版）都卖到 40 了（http://act.vip.xunlei.com/wow.html），这很明显地说明了市场巨大，能不能赚大钱，完全就靠能不能通过技术手段有效地降低成本和通过营销手段增加用户量。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_151859" href="https://my.oschina.net/umu618/blog/151859">只留哈希不留种</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-08-10 23:21:24</div>
                <div class='catalog'>分类：业余作品</div>
                                                                            </div>
            <div class='content'>下载链接http://sdrv.ms/1bkNAr4&nbsp;文件：HashToDownloadLink.7z使用方法从某些网站上获得 Hash 值，复制到界面上的文本输入框里，即可。不要问 UMU 从哪里获取 Hash 值，UMU 只交流技术，不交流片源&hellip;&hellip;举个例子：C4076BE038644B862E907C69465989D361EBF08*（仅作为举例，为了不指向实际内容，特地隐藏最后一个字符）神马是 Hash？就是种子的种子。参考文章通过 BT 种子 Hash 值从 BitComet 服务器上下载种子文件通过 BT 种子 info_hash 值下载种子又一法如何用微博传播小电影拖个种子到百度云，就可以在线看了！</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_167024" href="https://my.oschina.net/umu618/blog/167024">[UMU WSH 教程](45) WIA 应用实例 - 按图片拍摄时间批量重命名</a></h2>
            <div class='outline'>
                <div class='date'>时间：2013-10-06 23:02:08</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>UMU WSH 教程代码下载：http://sdrv.ms/ZpPPaS   UMU WSH Git：http://git.oschina.net/umu618/umu-wsh   &nbsp;&nbsp;&nbsp;&nbsp;有些图片不是按照时间命名的，这让 UMU 觉得很蛋疼，因为 UMU 喜欢拍照，从 2006 年有 Nokia 6300 就开始经常拍，然后都按照年份，年份-月份归类了，这样比较好查看。所以这个脚本就诞生了。  ' 45_RenameImageToDateTime.VBS' UMU @ 8:18 2013/10/5' [UMU WSH 教程](45) WIA 应用实例 - 按图片拍摄时间批量重命名Option ExplicitConst APP_TITLE = &quot;UMU.Script.Tools.RenameImageToDateTime&quot;Const APP_DESCRIPTION = &quot;本程序用来把带 EXIF 信息的图片按拍摄时间批量重命名。&quot;Const APP_USAGE = &quot;请把要处理的文件或文件夹拖放到本程序的图标上！&quot;Dim args, fsoSet args = WScript.ArgumentsSet fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)If args.Count = 0 Then    Dim wsh    Dim send_to, copy_to    MsgBox APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE, vbInformation, APP_TITLE    Set wsh = CreateObject(&quot;WScript.Shell&quot;)    send_to = wsh.SpecialFolders(&quot;SendTo&quot;)    copy_to = send_to &amp; &quot;\bmp2png.VBE&quot;    If Not fso.FileExists(copy_to) Then        If vbOK = MsgBox(APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE &amp; vbCrLf &amp; vbCrLf &amp; _            &quot;提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。&quot; &amp; vbCrLf &amp; _            &quot;您的 Sendto 目录是 &quot; &amp; send_to &amp; vbCrLf &amp; &quot;按“确定”执行复制操作。&quot;, _            vbOKCancel + vbInformation, APP_TITLE) Then                        fso.CopyFile WScript.ScriptFullName, copy_to            If vbYes = MsgBox(&quot;是否查看 Sendto 目录？&quot;, vbQuestion + vbYesNo, APP_TITLE) Then                wsh.Run &quot;%SystemRoot%\explorer.exe /n, /select,&quot; &amp; copy_to            End If        End If    End If    Set fso = Nothing    Set wsh = Nothing    Set args = Nothing    WScript.QuitEnd IfDim is_moveis_move = MsgBox(&quot;重命名文件？按“否”复制文件，按“取消”退出！&quot;, vbYesNoCancel + vbQuestion, &quot;询问&quot;)If vbCancel = is_move Then    Set args = NothingSet fso = Nothing    WScript.QuitEnd IfDim target_directorytarget_directory = InputBox(&quot;请输入存放目录：&quot;, &quot;存放目录&quot;)If Len(target_directory) = 0 ThenSet args = NothingSet fso = Nothing    WScript.QuitEnd IfIf Not fso.FolderExists(target_directory) ThenSet args = NothingSet fso = NothingMsgBox target_directory, vbError, &quot;存放目录不存在&quot;    WScript.QuitEnd IfIf Right(target_directory, 1) &lt;&gt; &quot;\&quot; Thentarget_directory = target_directory &amp; &quot;\&quot;End IfDim ar, succeeded_count, failed_count, exists_countsucceeded_count = 0failed_count = 0exists_count = 0For Each ar In args    If fso.FolderExists(ar) Then        Call RenameImageToDateTime_s(ar)    ElseIf fso.FileExists(ar) Then        Call RenameImageToDateTime(ar)    End IfNextSet args = NothingSet fso = NothingMsgBox &quot;重命名 &quot; &amp; succeeded_count &amp; &quot; 个，失败 &quot; &amp; failed_count &amp; _    &quot; 个，文件已经存在 &quot; &amp; exists_count &amp; &quot; 个！&quot;, 4160, &quot;整个世界清净了！&quot;Private Sub RenameImageToDateTime_s(ByVal folder_path)    'On Error Resume Next    Dim rfd, fs, f, fds, fd    Set rfd = fso.GetFolder(folder_path)    Set fs = rfd.Files    For Each f In fs        Call RenameImageToDateTime(f.Path)    Next    Set fds = rfd.SubFolders    For Each fd In fds        Call RenameImageToDateTime_s(fd.Path)    NextEnd SubPrivate Sub RenameImageToDateTime(ByRef file_path)    On Error Resume NextDim dtdt = GetImageDateTime(file_path)If Len(dt) &gt; 0 ThenDim y, mDim pathy = Left(dt, 4)m = Mid(dt, 6, 2)path = target_directory &amp; yIf Not fso.FolderExists(path) ThenCall fso.CreateFolder(path)End Ifpath = path &amp; &quot;\&quot; &amp; y &amp; &quot;-&quot; &amp; mIf Not fso.FolderExists(path) ThenCall fso.CreateFolder(path)End IfIf Err.Number &lt;&gt; 0 Thenfailed_count = failed_count + 1Err.ClearExit SubEnd IfDim extext = Mid(file_path, InStrRev(file_path, &quot;.&quot;))path = path &amp; &quot;\&quot; &amp; dt &amp; extIf fso.FileExists(path) Thenexists_count = exists_count + 1ElseIf vbYes = is_move Thenfso.MoveFile file_path, pathIf Err.Number &lt;&gt; 0 Thenfailed_count = failed_count + 1Err.ClearElsesucceeded_count = succeeded_count + 1End IfElsefso.CopyFile file_path, pathIf Err.Number &lt;&gt; 0 Thenfailed_count = failed_count + 1Err.ClearElsesucceeded_count = succeeded_count + 1End IfEnd IfEnd IfEnd SubPrivate Function GetImageDateTime(ByRef file_path)    On Error Resume Next    GetImageDateTime = &quot;&quot;    Dim image_file    Set image_file = CreateObject(&quot;WIA.ImageFile&quot;)    image_file.LoadFile file_path    If Err.Number &lt;&gt; 0 Then' 可能不是图像，或者图像格式无法识别        Exit Function    End IfDim dtDim prop_namesDim nameprop_names = Array(&quot;DateTime&quot;, &quot;ExifDTOrig&quot;, &quot;ExifDTDigitized&quot;)For Each name In prop_namesIf image_file.Properties.Exists(name) ThenDim propSet prop = image_file.Properties(name)dt = prop.ValueSet prop = NothingExit ForEnd IfNextSet image_file = NothingIf Len(dt) &gt; 0 Thendt = Replace(dt, &quot;/&quot;, &quot;-&quot;)dt = Replace(dt, &quot;:&quot;, &quot;-&quot;)dt = Replace(dt, &quot; &quot;, &quot;_&quot;)GetImageDateTime = dtEnd IfEnd Function  &nbsp;</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_214675" href="https://my.oschina.net/umu618/blog/214675">DuiLib 经验：控件没有 GetRect 接口？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-03-31 10:44:08</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>上周写一个基于 DuiLib 开源界面库的程序，需要取到控件的 Rect，找了很久文档和头文件，没有发现 GetRect 这个函数（用于获得控件矩形），后来想想可能要自己加强一下了，就把控件的基类代码从头看了一遍，才看到以下函数 const RECT&amp; CControlUI::GetPos() const 恍然大悟，原来是这个代码的作者误用……Pos 是位置，由一个点 (x, y) 表示，而 Rect 是一个矩形，由两个点表示 (left, top, right, bottom)，这个函数名字是 GetPos，却返回 RECT 类型，其实函数名应该为 GetRect 才对。 特作此文，提醒一下大家。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_264935" href="https://my.oschina.net/umu618/blog/264935">Windows 8 和 OpenWRT 下查看 WiFi 属性</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-05-14 18:39:33</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>从 Win7 到 Win8，部分 WiFi 属性被隐藏掉了，在图形界面上看不到……只好用命令行了： netsh&nbsp;wlan&nbsp;show&nbsp;networks&nbsp;mode=bssid OpenWRT 上是： iw&nbsp;dev&nbsp;wlan0&nbsp;scan</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_267435" href="https://my.oschina.net/umu618/blog/267435">跟 UMU 一起玩 OpenWRT（高级篇1）：编译不死 U-Boot</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-05-21 16:14:31</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;UMU&nbsp;2010 年初就玩 OpenWRT/DD-WRT 了，蛋似编译东西还是初学者，本文纯属蛋疼的过程，欢迎批评教育，谢谢…… &nbsp;&nbsp;&nbsp;&nbsp;首先到 https://github.com/pepe2k/u-boot_mod&nbsp;看明白作者的说明。这里简单说一下原理：固件（firmware）刷坏，但 U-Boot 没坏，这是半砖，可以用 TTL 线连路由器，通过 U-Boot 的功能刷好 firmware。如果两者都坏了，叫全砖，只能把 Flash 拆下来，用编程器刷好 U-Boot 和 firmware。不死 U-Boot 就是修改了 U-Boot 的实现，使我们可以用 RJ-45 网线来救砖，省去拆机搭 TTL 线的麻烦。 &nbsp;&nbsp;&nbsp;&nbsp;本质上说，这东西并非真的不死，只要 U-Boot 被刷坏了，还是会死，不过几率不大，因为 OpenWRT 官方发行的 ROM 全都是保护 U-Boot 区域的，根据 UMU 的经验，只有三个情况会不小心或故意刷坏：1、从原厂固件刷不良固件；2、在 DD-WRT 下搞破坏（DD-WRT 没有保护 U-Boot）；3、自制固件去掉 U-Boot 写保护后搞破坏……如果您真的这么蛋疼，还是准备编程器吧，只要是软件问题，在编程器面前没有砖的概念。（JTAG 也是救砖神器，但不是每台路由器都有，比如 DIR-505 就没有！） &nbsp;&nbsp;&nbsp;&nbsp;由于 UMU 是&nbsp;Windows 程序员，平时没有安装 Linux 桌面的习惯，蛋似由于做快游项目，买了不少服务器，都是 CentOS，所以第一步就是在 CentOS 上尝试编译，后来，您们懂的，爆出各种 213 码！服务器系统还是不适合开发！ &nbsp;&nbsp;&nbsp;&nbsp;不得已就在 Hyper-V Server 2012 上安装了 Ubuntu 12.04.1-desktop-i386，本来是想安装 x64 版本的，但又怕这些嵌入式的东西对 x64 可能支持不够好，算了，不要装 13 了。 &nbsp;&nbsp;&nbsp;&nbsp;接下来是选择编译环境了，按照 UMU 对 OpenWRT 的好感，明显是选择 OpenWrt Toolchain for AR71xx MIPS，然后开始编译，哗哗哗，编译好了……最后编译出来的 bin 却是 64KB+110B，尼玛，这 size 超标了，刷进去不是不死，是立刻死！ &nbsp;&nbsp;&nbsp;&nbsp;然后终于明白了，作者其实并没有用这个编译过，他是用 Sourcery CodeBench Lite Edition for MIPS GNU/Linux&nbsp;的，所以……为了节省时间，还是和作者保持一致吧！吐槽一下，这是商业软件，虽然有免费的 Lite 版本，但没搞明白为什么作者不用 OpenWRT 的…… &nbsp;&nbsp;&nbsp;&nbsp;make dlink_dir505 一下，最后当然就编译出来了，UMU 还小修改了一下 Web 界面，加入了自己的特色，不过要提醒一下，不要加太多，会爆……只有 64KB 的空间！</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_267912" href="https://my.oschina.net/umu618/blog/267912">跟 UMU 一起玩 OpenWRT（高级篇2）：不拆机刷不死 U-Boot</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-05-23 00:23:50</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;在上一篇《编译 D-Link DIR-505 的不死 U-Boot》介绍了如何编译不死 U-Boot，但是不死 U-Boot 的作者只介绍了用 TTL 线刷方法，UMU 可不想拆机，毕竟拆机感觉并不好…… &nbsp;&nbsp;&nbsp;&nbsp;第一个思路是刷上 DD-WRT 固件，但是找了一下 DD-WRT 木有支持 DIR-505，只好继续蛋疼地编译 OpenWRT。 &nbsp;&nbsp;&nbsp;&nbsp;第一遍在虚拟机从 12:20 编译到 23:56，花了将近 12 小时……刚开始时，有一个下载过程，不断失败，想想是因为公司的网络太烂了，于是把下载脚本改了一下： &lt;openwrt-svn-dir&gt;/trunk/scripts/download.pl 中的 wget -t5 --timeout=20 --no-check-certificate 改为 wget -t5 --timeout=120 --no-check-certificate &nbsp;&nbsp;&nbsp;&nbsp;第二天来，刷上，没问题，于是开始改代码去掉 U-Boot 写保护，参考这篇《Openwrt 中刷写 uboot ART》http://see.sl088.com/wiki/Openwrt_%E4%B8%AD%E5%88%B7%E5%86%99_uboot_art，但结果很不幸，型号不同嘛！ &nbsp;&nbsp;&nbsp;&nbsp;接下来，凭自己的编程水平了，尝试改 &lt;openwrt-svn-dir&gt;/trunk/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-505-a1.c，加入下面两个结构体： static&nbsp;struct&nbsp;mtd_partition&nbsp;dir505_partitions[]&nbsp;=&nbsp;{&nbsp;{&nbsp;&nbsp;.name&nbsp;&nbsp;=&nbsp;&quot;u-boot&quot;,&nbsp;&nbsp;.offset&nbsp;&nbsp;=&nbsp;0,&nbsp;&nbsp;.size&nbsp;&nbsp;=&nbsp;0x010000,&nbsp;&nbsp;.mask_flags&nbsp;=&nbsp;0,&nbsp;},&nbsp;{&nbsp;&nbsp;.name&nbsp;&nbsp;=&nbsp;&quot;art&quot;,&nbsp;&nbsp;.offset&nbsp;&nbsp;=&nbsp;0x010000,&nbsp;&nbsp;.size&nbsp;&nbsp;=&nbsp;0x010000,&nbsp;},&nbsp;{&nbsp;&nbsp;.name&nbsp;&nbsp;=&nbsp;&quot;mac&quot;,&nbsp;&nbsp;.offset&nbsp;&nbsp;=&nbsp;0x020000,&nbsp;&nbsp;.size&nbsp;&nbsp;=&nbsp;0x010000,&nbsp;},&nbsp;{&nbsp;&nbsp;.name&nbsp;&nbsp;=&nbsp;&quot;nvram&quot;,&nbsp;&nbsp;.offset&nbsp;&nbsp;=&nbsp;0x030000,&nbsp;&nbsp;.size&nbsp;&nbsp;=&nbsp;0x010000,&nbsp;},&nbsp;{&nbsp;&nbsp;.name&nbsp;&nbsp;=&nbsp;&quot;language&quot;,&nbsp;&nbsp;.offset&nbsp;&nbsp;=&nbsp;0x040000,&nbsp;&nbsp;.size&nbsp;&nbsp;=&nbsp;0x040000,&nbsp;},&nbsp;{&nbsp;&nbsp;.name&nbsp;&nbsp;=&nbsp;&quot;firmware&quot;,&nbsp;&nbsp;.offset&nbsp;&nbsp;=&nbsp;0x080000,&nbsp;&nbsp;.size&nbsp;&nbsp;=&nbsp;0x780000,&nbsp;&nbsp;.mask_flags&nbsp;=&nbsp;0,&nbsp;}};static&nbsp;struct&nbsp;flash_platform_data&nbsp;dir505_flash_data&nbsp;=&nbsp;{&nbsp;.parts&nbsp;&nbsp;=&nbsp;dir505_partitions,&nbsp;.nr_parts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;ARRAY_SIZE(dir505_partitions),}; &nbsp;&nbsp;&nbsp;&nbsp;并将 dir_505_a1_setup 函数里的 ath79_register_m25p80(NULL); 改为&nbsp;ath79_register_m25p80(&amp;dir505_flash_data); &nbsp;&nbsp;&nbsp;&nbsp;测试还是无效……看来必须在源头上使 MTD_WRITEABLE 无效掉，grep -r MTD_WRITEABLE &lt;openwrt-svn-dir&gt;/trunk/build_dir/target-mips_34kc_uClibc-0.9.33.2/linux-ar71xx_generic/linux-3.10.36/drivers/mtd，看到几处关键的地方： if&nbsp;(!(ubi-&gt;mtd-&gt;flags&nbsp;&amp;&nbsp;MTD_WRITEABLE))&nbsp;{ 和 if&nbsp;(!mtd-&gt;_write&nbsp;||&nbsp;!(mtd-&gt;flags&nbsp;&amp;&nbsp;MTD_WRITEABLE)) &nbsp;&nbsp;&nbsp;&nbsp;主要在 mtd_erase、mtd_write 等函数，很明显，C 语言不管在什么平台都是很好懂，看几眼就搞定了，原理是使 MTD_WRITEABLE 这个标志无用掉，您可以设置，但是我把判断这个标志的代码全干掉了，设了也是白设！ &nbsp;&nbsp;&nbsp;&nbsp;最后编译好的 openwrt-ar71xx-generic-dir-505-a1-squashfs-sysupgrade.bin，用 sysupgrade 刷一下，reboot 后再用 mtd 刷不死 U-Boot，一切顺利，成功刷上不死 U-Boot！</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_268466" href="https://my.oschina.net/umu618/blog/268466">跟 UMU 一起玩 OpenWRT（入门篇1）：硬件选型和刷机</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-05-24 01:14:14</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;看了《跟hoowa学做智能路由》系列，http://www.leiphone.com/diy-a-smart-router.html，也想写点自己的经验，大家可以先看 hoowa 童鞋的，他已经写得很好了，UMU 的不同观点是硬件的选择而已。 &nbsp;&nbsp;&nbsp;&nbsp;首先声明，UMU 不是 D-Link 员工，也不卖 DIR-505，用它完全是对比了几个可选项筛选后的结果。理由： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、本身就是不死 Bootloader，刷坏了固件用网线就可以救了，把电脑 IP 设为 192.168.0.100，按住 Reset 开机，Web 浏览器访问 192.168.0.1。前面写的《不拆机给 D-Link DIR-505 刷上不死 U-Boot》完全是蛋疼地研究过程，对一般用户 UMU 建议不要刷，因为没有 JTAG，刷固件本来就不死了，不小心刷坏了 Bootloader 就只能拆机上编程器了，这明显作死。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、配置比较高（相比 TP-Link 坑爹级同价位产品），8MB Flash，64MB RAM，UMU 手头上还有三个 TP 的（TL-WR841N、743N、941N）都只有它一半。有 USB 2.0 接口，743N 的 USB 是 1.1 的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、国内电商有得买，而且价格便宜，UMU 买的时候是 78 块。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、小巧，方便携带，随时开撸！ &nbsp;&nbsp;&nbsp;&nbsp;也说一下它的缺点：没有外接天线，所以您懂的，信号必然比较弱，不适合穿墙族……然后 RJ45 口只有一个，有时候会不太方便。它最适合的使用场景是研究 OpenWRT、短距离和出差便捷使用。 &nbsp;&nbsp;&nbsp;&nbsp;接下来就刷个 OpenWRT 先~目前没有稳定发行版支持 DIR-505，所以要在 trunk 下找，下载目录是：http://downloads.openwrt.org/snapshots/trunk/ar71xx/。如果直接开刷，很可能失败，因为 D-Link 是有锁区的，OpenWRT.org 编译的 ROM&nbsp;不是为中国版准备的，所以要动一下手脚先。上 WinHex 改 ROM，下面两张图分别是中国版和国际版：  中国版  国际版 &nbsp;&nbsp;&nbsp;&nbsp;两者只是图片指出的位置不同而已，可以自己改，如果把 OpenWRT 的 ROM 改为 CN 也无法在原厂 ROM 下刷成功的话，可以先找个官方的 DEF ROM 改为 CN，刷一下，再刷 OpenWRT 原版的 DEF ROM。</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_269744" href="https://my.oschina.net/umu618/blog/269744">极路由升级保留 root 方法</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-05-27 15:37:07</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;请先确认已经 root！SSH 连到路由器上（推荐使用 putty 和 winscp），按下列步骤操作： 1、在 /etc/rc.local 里加入 /etc/init.d/dropbear&nbsp;enable/etc/init.d/dropbear&nbsp;start 2、在 /etc/sysupgrade.conf 里加入 /etc/rc.local &nbsp;&nbsp;&nbsp;&nbsp;理论上其它已经 root 的路由器都可以这么干，但把 ROM 放在硬盘的发“烧”神器小米路由是已知的例外。升级之前检查一下，确保上面操作都成功了。 &nbsp;&nbsp;&nbsp;&nbsp;以上方法有人反馈在最新版的 ROM 已经失效，但 UMU 已经没有极路由了测试了，可以试试这个： touch&nbsp;/lib/upgrade/keep.d/basevi&nbsp;/lib/upgrade/keep.d/base 添加下面三行： /etc/rc.local/lib/upgrade/keep.d/base/etc/sysupgrade.conf</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_271630" href="https://my.oschina.net/umu618/blog/271630">跟 UMU 一起玩 OpenWRT（入门篇2）：连上路由器</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-02 01:00:35</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>连上路由器  &nbsp;&nbsp;&nbsp;&nbsp;刚刚刷好 OpenWRT 的 DIR-505，默认没有开启 WiFi，所以只能用网线连接，连起来后，将电脑的网卡配置为 192.168.1.X，或者自动获得地址也行。 &nbsp;&nbsp;&nbsp;&nbsp;默认也没有开启 SSH，只能用 telnet 192.168.1.1 来连，连上后改 root 密码： passwd&nbsp;root  &nbsp;&nbsp;&nbsp;&nbsp;改好密码后，先不要关闭 telnet，因为一关闭，下次就连不上了。马上用 SSH 客户端（推荐使用 putty，文件复制、编辑则推荐 winscp）连一下路由器： ssh&nbsp;192.168.1.1  &nbsp;&nbsp;&nbsp;&nbsp;如果连接失败，需要在 telnet 会话下开启 SSH 服务： /etc/init.d/dropbear&nbsp;enable/etc/init.d/dropbear&nbsp;start  开启 WiFi &nbsp;&nbsp;&nbsp;&nbsp;用有线连接比较麻烦，接下来开启 WiFi，实现无线连接：   uci set wireless.@wifi-device[0].disabled=0;uci set wireless.@wifi-iface[0].ssid='umu618.com';uci set wireless.@wifi-iface[0].encryption='psk2+ccmp';uci set wireless.@wifi-iface[0].key='password';uci commit wireless;wifi  改时区 &nbsp;&nbsp;&nbsp;&nbsp;时间都用网络同步，所以使用正确的时区很重要，要改为当地的时区，比如 UMU 使用台北时间：   uci set system.@system[0].zonename='Asia/Taipei'; uci set system.@system[0].timezone='CST-8'; uci commit system; echo CST-8 &gt; /etc/TZ;  改机器名 &nbsp;&nbsp;&nbsp;&nbsp;个性化，非必要：   uci set system.@system[0].hostname='DIR-505'; uci commit system; /etc/init.d/dnsmasq restart;  改欢迎语 &nbsp;&nbsp;&nbsp;&nbsp;个性化，非必要： vi&nbsp;/etc/banner</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_272249" href="https://my.oschina.net/umu618/blog/272249">考题：为什么 Shell 脚本自动把字符串 10001 当成二进制，输出 17？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-04 11:05:05</div>
                <div class='catalog'>分类：考题</div>
                                                                            </div>
            <div class='content'>#!/bin/shtest()&nbsp;{&nbsp;v='10001';&nbsp;return&nbsp;$v;}test;echo&nbsp;$?  运行后输出 17（二进制10001的十进制17），解释一下？</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_272515" href="https://my.oschina.net/umu618/blog/272515">安全性堪忧的门禁系统</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-04 21:46:56</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;天天刷卡开门，不知道大家有没有考虑到门禁的安全性。按照 UMU 的设想，门禁的原理应该是：刷卡器获得卡信息，到服务器比较，若合法，则服务器下令开门。但现实中，有的门禁却不是这样的，下令开门的不是服务器，而是刷卡器！！！ &nbsp;&nbsp;&nbsp;&nbsp;UMU 与门禁的亲密接触发生在 2013-11-13，第二次不小心被关在厕所，忘记带卡，结果出不来，想起第一次是多么惨，最后让住公司附近的同事过来拯救。但总不能第二次又麻烦人家吧！于是开始了研究破解，不到 5 分钟，门就被打开了…… &nbsp;&nbsp;&nbsp;&nbsp;原理：这套门禁系统是直接由刷卡器控制门的开关的，所以在刷卡器这边就可以打开门，不需要经过服务器认证，我们要做的就是找到 OPEN 针脚，把它和 GND 针脚接起来，门就开了。 &nbsp;&nbsp;&nbsp;&nbsp;理论上说，门禁刷卡器很好拆，即使不好拆，一把锤子就能砸烂，所以对入侵者来说，只要具备野蛮和电路知识，破解的难度是相当低啊！ &nbsp;&nbsp;&nbsp;&nbsp;不罗嗦，上图！这是要破解的门禁刷卡器。   &nbsp;&nbsp;&nbsp;&nbsp;徒手温柔地打开……  &nbsp;&nbsp;&nbsp;&nbsp;去掉排线，就可以看到 OPEN 的针脚了：  &nbsp;&nbsp;&nbsp;&nbsp;连接 OPEN 和 GND，门就开了！  &nbsp;</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_273945" href="https://my.oschina.net/umu618/blog/273945">跟 UMU 一起玩 OpenWRT（入门篇3）：工作模式开关</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-05 19:00:48</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;DIR-505 有一个工作模式开关，可以设定三个模式，但刷了 OpenWRT 后，默认没有任何功能，我们可以利用 GPIO 读取获得开关的位置。 #!/bin/shread_gpio()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;(echo&nbsp;$1&nbsp;&gt;&nbsp;/sys/class/gpio/export)&nbsp;&gt;&amp;&nbsp;/dev/null&nbsp;&nbsp;&nbsp;&nbsp;(echo&nbsp;&quot;in&quot;&nbsp;&gt;&nbsp;/sys/class/gpio/gpio$1/direction)&nbsp;&gt;&amp;&nbsp;/dev/null&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;`cat&nbsp;/sys/class/gpio/gpio$1/value`;}read_gpio&nbsp;19;v=$?;read_gpio&nbsp;20;v=$v$?;read_gpio&nbsp;21;v=$v$?;read_gpio&nbsp;22;v=$v$?;read_gpio&nbsp;23;v=$v$?;case&nbsp;&quot;$v&quot;&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;10001)&nbsp;v=&quot;ap&quot;;;&nbsp;&nbsp;&nbsp;&nbsp;11001)&nbsp;v=&quot;repeater&quot;;;&nbsp;&nbsp;&nbsp;&nbsp;01001)&nbsp;v=&quot;hotspot&quot;;;&nbsp;&nbsp;&nbsp;&nbsp;11000)&nbsp;v=&quot;4th&quot;;;&nbsp;&nbsp;&nbsp;&nbsp;*)&nbsp;v=&quot;error&quot;;;esacecho&nbsp;$v; &nbsp;&nbsp;&nbsp;&nbsp;按照 OpenWRT 官网资料（http://wiki.openwrt.org/toh/d-link/dir-505#buttons），有一款 DIR-505L 的开关是四个档位的，DIR-505 其实也有，但外壳把第四个档位给挡住了，掰不到。如果您足够蛋疼，可以用刻刀给它开开口…… &nbsp;&nbsp;&nbsp;&nbsp;我们可以在开机脚本（/etc/rc.local）里加入判断代码，根据档位做不同配置，以实现不同用途。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_279956" href="https://my.oschina.net/umu618/blog/279956">极路由 1S 使用经验</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-15 17:58:26</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;优点，基本全在硬件上。 1、不贵，性价比不错； 2、铝合金外壳，体型小巧，散热性好； 3、MicroUSB 电源接口，停电时可以用移动电源供电（最近宿舍跳闸停电三次，还不得不提一下，这绝对是优点！）； 4、两根天线，信号还行，虽然不如小米路由，但考虑到价格还是过得去。 5、可以插 SD 卡，这个能秒杀很多传统路由。  &nbsp;&nbsp;&nbsp;&nbsp;硬件上的明显缺点： 1、不贴防滑贴在办公桌上很容易滑……这个是设计硬伤！ 2、没有 USB，这明显少了很多扩展性，还敢自称智能？  &nbsp;&nbsp;&nbsp;&nbsp;主要缺点在软件上： 1、不稳定，每个开发版都应该吐槽，办公室的 MAC OS 机器一连上来就出现一天死一次的问题，CPU 占用率超高！ 2、定位很忽悠。您说智能吧，只是界面和使用流程得到一点点优化，再说面向极客吧……极客需要那些给小白用的界面？这明显是面向装逼的初级技术人员。一天死一次，就不要说极客了…… 3、服务态度问题。App 不支持 Windows Phone。注册个账号哟手机，然后 UMU 手机换号了，联系了官方客服、在论坛上问了，都不让改，让 UMU 再注册一个账号……逛了几周的论坛，发现各位坛友大部分是小白，所以官方不断发一些扫盲的科普文，品质和逼格都不高，可以说根本没有极客间的交流。  &nbsp;&nbsp;&nbsp;&nbsp;当然，最近有朋友让 UMU 推荐路由器，UMU 还是建议他们买极路由 1S，回来刷 OpenWRT，自己整吧！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_279963" href="https://my.oschina.net/umu618/blog/279963">小米路由使用经验</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-15 18:27:48</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;小米路由比极路由 1S 还早买，但用了一周后就决定把他收起来了…… 1、0.4.58 的版本，下载功能根本不能用，人品真差，同样的种子，1S 就可以下载！我有朋友也这样，看来不是个例。 2、发烧……您说替代 NAS 吧，就一个硬盘而已，缓存还只有 8MB，一天就开机&nbsp;9 小时左右，每天下班都是暖手宝。 3、太 TM 贵了，收起来还有点浪费啊！ &nbsp;&nbsp;&nbsp;&nbsp;话说回来，UMU 是看好小米路由的，配置真心高，虽然大部分人不需要，但也提一下优点： 1、千兆网口啊！高富帅家里怎么能没有千兆独享的宽带？ 2、USB 啊！尼玛，插个 USB 声卡就可以做窃听器了，您造吗？扩展性超高，堪称智能……前提是 root。 3、信号超好啊！虽然天线内置，但有 4 根啊，秒杀极路由 1S。重点还很稳定，Windows、MAC OS、Android、iOS、WP 各种设备都一起连上来，MAC OS 和 iOS 都不会掉线哦！ 4、11AC 超快啊！干扰少啊！ 5、黑色垃圾桶的造型，让您放在角落也毫无违和感，它真的很像另一个角落的垃圾桶。（风扇有声，放角落才不会吵）</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_280295" href="https://my.oschina.net/umu618/blog/280295">跟 UMU 一起玩 OpenWRT（入门篇4）：启用工作模式开关和联网</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-16 19:23:07</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;在上篇《跟 UMU 一起玩 OpenWRT（入门篇3）：工作模式开关》（http://my.oschina.net/umu618/blog/273945）中介绍了如何通过 GPIO 读取获得当前工作模式，现在来实现这个开关的功能。   &nbsp;&nbsp;&nbsp;&nbsp;主要配置 rc.local 脚本，内容如下：  read_gpio()&nbsp;{&nbsp;(echo&nbsp;$1&nbsp;&gt;&nbsp;/sys/class/gpio/export)&nbsp;&gt;&amp;&nbsp;/dev/null&nbsp;(echo&nbsp;&quot;in&quot;&nbsp;&gt;&nbsp;/sys/class/gpio/gpio$1/direction)&nbsp;&gt;&amp;&nbsp;/dev/null&nbsp;return&nbsp;`cat&nbsp;/sys/class/gpio/gpio$1/value`;}read_gpio&nbsp;19;v=$?;read_gpio&nbsp;20;v=$v$?;read_gpio&nbsp;21;v=$v$?;read_gpio&nbsp;22;v=$v$?;read_gpio&nbsp;23;v=$v$?;case&nbsp;&quot;$v&quot;&nbsp;in&nbsp;10001)&nbsp;v=&quot;ap&quot;;;&nbsp;11001)&nbsp;v=&quot;repeater&quot;;;&nbsp;01001)&nbsp;v=&quot;hotspot&quot;;;&nbsp;11000)&nbsp;v=&quot;4th&quot;;;&nbsp;*)&nbsp;v=&quot;error&quot;;;esaccp&nbsp;/etc/config/$v/*&nbsp;/etc/config/logger&nbsp;working&nbsp;mode:&nbsp;$vexit&nbsp;0  &nbsp;&nbsp;&nbsp;&nbsp;原理是开机自动复制配置文件覆盖到 /etc/config/ 下，配置文件不需要全部，只要 firewall、network 和 wireless 就行了。按工作模式命名，创建三个目录：  mkdir&nbsp;/etc/config/apmkdir&nbsp;/etc/config/repeatermkdir&nbsp;/etc/config/hotspot  &nbsp;&nbsp;&nbsp;&nbsp;后面，我们会把配置文件写好了，放在这些目录里。下面以 ap 为例，此模式是网口做 WAN，无线做 LAN，WAN 以&nbsp;ADSL 接入为例，其它情况自行变通：  uci&nbsp;set&nbsp;wireless.@wifi-device[0].disabled=0;uci&nbsp;set&nbsp;wireless.@wifi-iface[0].ssid='umu618.com';uci&nbsp;set&nbsp;wireless.@wifi-iface[0].encryption='psk2+ccmp';uci&nbsp;set&nbsp;wireless.@wifi-iface[0].key='WiFi&nbsp;密码';uci&nbsp;commit&nbsp;wireless;wifiuci&nbsp;delete&nbsp;network.lan.ifnameuci&nbsp;delete&nbsp;network.lan.typeuci&nbsp;add&nbsp;network&nbsp;interfaceuci&nbsp;rename&nbsp;network.@interface[-1]='wan'uci&nbsp;set&nbsp;network.@interface[-1].ifname='eth1'uci&nbsp;set&nbsp;network.@interface[-1]._orig_ifname='eth1'uci&nbsp;set&nbsp;network.@interface[-1]._orig_bridge='false'uci&nbsp;set&nbsp;network.@interface[-1].proto='pppoe'uci&nbsp;set&nbsp;network.@interface[-1].username='宽带账号'uci&nbsp;set&nbsp;network.@interface[-1].password='宽带密码'uci&nbsp;commit&nbsp;networkcp&nbsp;/etc/config/firewall&nbsp;/etc/config/ap/cp&nbsp;/etc/config/network&nbsp;/etc/config/ap/cp&nbsp;/etc/config/wireless&nbsp;/etc/config/ap/  &nbsp;&nbsp;&nbsp;&nbsp;再来说一下 repeater，网口做 LAN，无线做一个 AP Client 和一个 AP。注意，以下命令以初始化的配置文件为基础，请事先备份、还原，不要在配置过前面的 ap 模式后直接继续配置，可能会有问题。  uci&nbsp;add&nbsp;network&nbsp;interfaceuci&nbsp;rename&nbsp;network.@interface[-1]='wwan'uci&nbsp;set&nbsp;network.@interface[-1].proto='dhcp'uci&nbsp;commit&nbsp;networkuci&nbsp;set&nbsp;wireless.@wifi-device[0].disabled=0;uci&nbsp;set&nbsp;wireless.@wifi-iface[0].ssid='umu618.com';uci&nbsp;set&nbsp;wireless.@wifi-iface[0].encryption='psk2+ccmp';uci&nbsp;set&nbsp;wireless.@wifi-iface[0].key='WiFi&nbsp;密码';uci&nbsp;add&nbsp;wireless&nbsp;wifi-ifaceuci&nbsp;set&nbsp;wireless.@wifi-iface[-1].network='wwan'uci&nbsp;set&nbsp;wireless.@wifi-iface[-1].ssid='现有&nbsp;WiFi&nbsp;名字'uci&nbsp;set&nbsp;wireless.@wifi-iface[-1].device='radio0'uci&nbsp;set&nbsp;wireless.@wifi-iface[-1].mode='sta'uci&nbsp;set&nbsp;wireless.@wifi-iface[-1].bssid='现有无线路由器的&nbsp;MAC&nbsp;地址'uci&nbsp;set&nbsp;wireless.@wifi-iface[-1].encryption='psk2+ccmp'uci&nbsp;set&nbsp;wireless.@wifi-iface[-1].key='现有&nbsp;WiFi&nbsp;密码'uci&nbsp;commit&nbsp;wireless;wifiuci&nbsp;get&nbsp;firewall.@zone[1].networkuci&nbsp;show&nbsp;firewall.@zone[1]uci&nbsp;set&nbsp;firewall.@zone[1].network='wan&nbsp;wan6&nbsp;wwan'uci&nbsp;commit&nbsp;firewall/etc/init.d/firewall&nbsp;restartcp&nbsp;/etc/config/firewall&nbsp;/etc/config/repeater/cp&nbsp;/etc/config/network&nbsp;/etc/config/repeater/cp&nbsp;/etc/config/wireless&nbsp;/etc/config/repeater/</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_282223" href="https://my.oschina.net/umu618/blog/282223">跟 UMU 一起玩 OpenWRT（入门篇5）：升级固件</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-20 01:05:47</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;OpenWRT 的主线于 2014-06-19 06:07:37 UTC 更新了固件，如果不跟随升级，安装内核模块时会失败，比如以下命令： opkg&nbsp;update&nbsp;opkg&nbsp;install&nbsp;kmod-hid &nbsp;&nbsp;&nbsp;&nbsp;升级很简单，三条命令搞定： cd&nbsp;/tmpwget&nbsp;http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-dir-505-a1-squashfs-sysupgrade.bin&nbsp;sysupgrade&nbsp;openwrt-ar71xx-generic-dir-505-a1-squashfs-sysupgrade.bin</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_282984" href="https://my.oschina.net/umu618/blog/282984">跟 UMU 一起玩 OpenWRT（入门篇6）：挂接 U 盘</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-23 00:49:39</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;DIR-505 有一个 USB2.0 接口，给它带来了很大的扩展性，我们可以插 U 盘、移动硬盘等，来做文件共享，或者离线下载等。接下来就先搞定 U 盘，主要参考资料：http://wiki.openwrt.org/doc/howto/usb.storage &nbsp;&nbsp;&nbsp;&nbsp;首先是 USB 和存储器的内核模块： opkg&nbsp;updateopkg&nbsp;install&nbsp;kmod-usb-storageopkg&nbsp;install&nbsp;kmod-scsi-generic &nbsp;&nbsp;&nbsp;&nbsp;然后是文件系统的： opkg&nbsp;install&nbsp;kmod-fs-ext4 &nbsp;&nbsp;&nbsp;&nbsp;USB 辅助工具、分区、格式化工具，这些非必要，看情况安装： opkg&nbsp;install&nbsp;usbutils&nbsp;fdisk&nbsp;e2fsprogs &nbsp;&nbsp;&nbsp;&nbsp;测试一下，不插 U 盘时，输入 lsusb，显示如下   Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub  &nbsp;&nbsp;&nbsp;&nbsp;插入 U 盘后，再 lsusb，发现多了一条，这说明工作正常：   Bus 001 Device 002: ID 0603:0908 Novatek Microelectronics Corp.  Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub  &nbsp;&nbsp;&nbsp;&nbsp;如果 U 盘需要重新分区，请用 fdisk，这里不具体介绍了，完全可以在 Windows 上用 diskpart 完成，如果您还在路由器上操作，可以参考这个：http://www.leiphone.com/diy-a-smart-router-topic-increase-memory-3.html，第一步: 对设备进行分区。 &nbsp;&nbsp;&nbsp;&nbsp;分区完后，查看一下 /dev 目录里有没有出现硬盘符和分区符： ls&nbsp;/dev&nbsp;|&nbsp;grep&nbsp;sd &nbsp;&nbsp;&nbsp;&nbsp;上面装了 ext4 文件系统的驱动，因为这个对 OpenWRT 最合适，如果原来不是这个格式，那么安装了 e2fsprogs 后就可以用下面命令格式化了： mkfs.ext4&nbsp;/dev/sda1 &nbsp;&nbsp;&nbsp;&nbsp;接下来用 mount 挂接，头尾行是必须，中间的三行是一种防止未挂接好就被写入的机制： mkdir&nbsp;/mnt/usbtouch&nbsp;/mnt/usb/USB_DISK_NOT_PRESENTchmod&nbsp;555&nbsp;/mnt/usbchmod&nbsp;444&nbsp;/mnt/usb/USB_DISK_NOT_PRESENTmount&nbsp;/dev/sda1&nbsp;/mnt/usb &nbsp;&nbsp;&nbsp;&nbsp;到这里就可以通过 /mnt/usb 来访问 U 盘了，不过工作才完成一半而已……下面还要让 U 盘能开机自动加载，主要参考：http://wiki.openwrt.org/doc/techref/block_mount&nbsp;和 http://wiki.openwrt.org/doc/uci/fstab。先安装程序： opkg&nbsp;install&nbsp;block-mount&nbsp;blkid &nbsp;&nbsp;&nbsp;&nbsp;如果您比较珍惜存储空间，可以不用安装 blkid，block-mount&nbsp;就行。用 blkid 或 block info，查看分区的 UUID，比如用 blkid，则 UMU 的 U 盘是显示：   /dev/mtdblock7: TYPE=&quot;squashfs&quot;  /dev/sda1: UUID=&quot;16e381bc-d9bb-40fd-9e98-410b346931ef&quot; TYPE=&quot;ext4&quot;  &nbsp;&nbsp;&nbsp;&nbsp;接下来输入 block detect 查看一下：   config 'global'  &nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;anon_swap&nbsp;'0'  &nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;anon_mount&nbsp;'0'  &nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;auto_swap&nbsp;'1'  &nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;auto_mount&nbsp;'1'  &nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;delay_root&nbsp;'5'  &nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;check_fs&nbsp;'0'  config 'mount'&nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;target&nbsp;'/mnt/sda1'&nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;uuid&nbsp;'16e381bc-d9bb-40fd-9e98-410b346931ef'&nbsp;&nbsp;&nbsp;&nbsp;option&nbsp;enabled&nbsp;'0'  &nbsp;&nbsp;&nbsp;&nbsp;生成配置文件，并把上面的 target 改为您想要的，enabled&nbsp;值改为 1： block&nbsp;detect&nbsp;&gt;&nbsp;/etc/config/fstabuci&nbsp;set&nbsp;fstab.@mount[-1].target='/mnt/usb'uci&nbsp;set&nbsp;fstab.@mount[-1].enabled=1uci&nbsp;commit&nbsp;fstab &nbsp;&nbsp;&nbsp;&nbsp;这里介绍的都是精简过的必须操作，其它可选项，请自行参考这个：http://wiki.openwrt.org/doc/uci/fstab。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_284552" href="https://my.oschina.net/umu618/blog/284552">跟 UMU 一起玩 OpenWRT（入门篇7）：安装 LUCI</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-06-26 20:30:15</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;UMU 不推荐安装 LUCI，还是多打命令好，可以学习更多东西，而且 LUCI 比较浪费存储空间！ opkg&nbsp;updateopkg&nbsp;install&nbsp;luci-ssl  &nbsp;&nbsp;&nbsp;&nbsp;推荐使用 SSL 版本，比较安全，但比较大，如果装不下可以试试不带 SSL 的： opkg&nbsp;install&nbsp;luci  &nbsp;&nbsp;&nbsp;&nbsp;您可能不习惯默认的主题（luci-theme-bootstrap），Flash 够大的话，还是装个常用的： opkg&nbsp;install&nbsp;luci-theme-openwrt  &nbsp;&nbsp;&nbsp;&nbsp;开启服务： /etc/init.d/uhttpd&nbsp;start  &nbsp;&nbsp;&nbsp;&nbsp;设置开机自动运行（不推荐）： /etc/init.d/uhttpd&nbsp;enable</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_289572" href="https://my.oschina.net/umu618/blog/289572">如意云使用经验</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-07-10 23:29:23</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　玩了好多个路由器，有传统，有所谓智能，还是比较赞赏如意云，相反的，之前已经吐槽过小米和圾路由。下面就来说说如意云的好处吧！ 　　１、生态完善，支持的移动设备多，连 WP8/8.1 都支持了，UMU 主要手机是 Lumia 822，这个很满足，还有 PC 客户端，方便 PC 和移动设备之间同步数据。插件齐全，虽然很多插件没具体玩过，但至少看数量是不输圾路由的。 　　2、很好滴继承 OpenWRT 的开放性，天生 root 了，或者专业点说，SSH 服务没关闭，直接连，省去很多烦恼，用小米或圾路由，老是怕一升级就要重新 root，好讨厌的感觉……还可以刷 PandoraBox：http://downloads.openwrt.org.cn/PandoraBox/RY-1/ 　　3、性价比不错，RY-01 才 81 元，从配置、功能、稳定性来比，差不多价位的传统路由完全不必考虑了。虽说运行内存和外壳材料方面不如圾 1S，但 USB 接口带来不少扩展性是圾 1S 没有的，而且 1S 要 109 元。 　　4、观其高配版 RY-02 配置也不落人后，后劲十足。 　　声明，这不是广告：要买的话，千万不要去迅雷商城，那边是 99 元，苏宁还是 81 元。 　　补充缺点： 　　1、很丑……一股廉价感，还真是对得起价格； 　　2、如意云的 WiFi 密码不能用,.#&amp;等特殊字符，好撒币的做法…… 　　3、WiFi 信号不如极路由 1S，虽然差距不大，但 UMU 还是通过实测数据挖掘出这个真相。</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_290697" href="https://my.oschina.net/umu618/blog/290697">跟 UMU 一起玩 OpenWRT（入门篇8）：网络摄像机</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-07-14 23:31:30</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　买了一个微软 LifeCam HD-3000，已经过了视频聊天的年纪，插到 DIR-505 玩一下吧。 　　安装过程出奇简单： opkg&nbsp;updateopkg&nbsp;install&nbsp;kmod-video-uvc  　　如果安装失败，看看是不是固件应该升级了，请参考《跟 UMU 一起玩 OpenWRT（入门篇5）：升级固件》。 　　插上摄像头，检查一下 /dev/video0 是否存在，如果不存在，reboot 一下，如果存在，接下来安装和运行应用： opkg&nbsp;install&nbsp;mjpg_streamer#&nbsp;使用&nbsp;MJPG&nbsp;格式，推荐：mjpg_streamer&nbsp;-i&nbsp;&quot;input_uvc.so&nbsp;-d&nbsp;/dev/video0&quot;&nbsp;-o&nbsp;&quot;output_http.so&nbsp;-p&nbsp;8080&nbsp;-w&nbsp;/www/webcam&quot;#&nbsp;使用&nbsp;YUV&nbsp;格式，多了一个&nbsp;-y&nbsp;参数，比较慢，不推荐：&nbsp;mjpg_streamer&nbsp;-i&nbsp;&quot;input_uvc.so&nbsp;-y&nbsp;-d&nbsp;/dev/video0&quot;&nbsp;-o&nbsp;&quot;output_http.so&nbsp;-p&nbsp;8080&nbsp;-w&nbsp;/www/webcam&quot;  　　其它可选输入参数，例如： -r 320x240 设置分辨率为320x240 &nbsp;-f 10 设置刷新率 　　设置用户密码，加输出参数： -c user:password 　　然后打开浏览器，输入 http://192.168.1.1:8080/&nbsp;测试，如果没问题，就参考网页上的说明吧！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_293642" href="https://my.oschina.net/umu618/blog/293642">跟 UMU 一起玩 OpenWRT（入门篇9）：远程监听</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-07-21 23:47:09</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　在《跟 UMU 一起玩 OpenWRT（入门篇8）：网络摄像机》介绍的 mjpg_streamer 并不能传输声音，所以有了本文，主要参考：http://forum.anywlan.com/thread-282658-1-1.html，硬件还是选用微软 LifeCam HD-3000，您也可以去淘个便宜的带麦克风的 USB 声卡。 　　悲剧的是，由于涉及声音编码，需要大量计算，经过实践 DIR-505 的 CPU 才&nbsp;400MHz，无论是 ogg 还是 MP3 格式都卡成翔……只好水一文了，大家自行参考以上链接。 　　提几个重点： 1、安装命令 opkg&nbsp;updateopkg&nbsp;install&nbsp;kmod-usb-audioopkg&nbsp;install&nbsp;icecast  如果您打算使用 ogg 格式则安装 ices： opkg&nbsp;install&nbsp;ices  用 mp3 格式则安装 darkice： opkg&nbsp;install&nbsp;darkice  2、ices 的配置文件（ices-oss.xml）可以去官网（http://www.icecast.org/ices.php）下载整个压缩包，里面有。 3、欢迎用配置更好的路由器测试，比如如意云 RY-01 的 CPU 是 600MHz 的，勉强可行。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_295193" href="https://my.oschina.net/umu618/blog/295193">跟 UMU 一起玩 OpenWRT（入门篇10）：穿透内网</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-07-27 00:45:32</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　UMU 把路由器放在公司，然后在家里想登陆它，这时候就有一个问题了：如何穿越到公司内网呢？答案就是：拨个 VPN 到公司去……然后本文就完了！ 　　哈，开个玩笑，当然是要说没有 VPN 用的情况了！ 　　真正的答案是：搞个 SSH 反向连接，然后用 autossh 保护起来。您需要准备一台有固定外网 IP 的服务器，UMU 使用的是某某云主机（避免广告嫌疑就不说了，呵，广告位招租），如果不想出钱购买，可以用家庭 ADSL + 动态域名代替，效果可能差一些，但基本可用。 　　为了更清晰地说明，列一下各个角色： 1、控制端：UMU 的笔记本，不管在什么网络，都要求能够连接到放在公司的路由器； 2、中转服务器：一台某某云主机，固定 IP，用 cloud_ip 表示； 3、被控端：放在公司的路由器，内网 IP，用 internal_ip 表示。 　　基本原理：让被控端主动连接中转服务器，然后控制端连接中转服务器，就可以间接连接被控端了。 　　被控端安装、设置，主要参考：http://wiki.openwrt.org/doc/howto/autossh opkg updateopkg install autosshdropbearkey -t rsa -f /etc/dropbear/id_rsadropbearkey -y -f /etc/dropbear/id_rsa | grep ssh-rsa 　　把上面最后一行命令的输出复制下，注意只有一行，待会儿要上传到中转服务器。或者也可以把最后一条命令改为打印到文件，再用 WinSCP 下载到本地。 dropbearkey&nbsp;-y&nbsp;-f&nbsp;/etc/dropbear/id_rsa&nbsp;|&nbsp;grep&nbsp;ssh-rsa&nbsp;&gt;&nbsp;/tmp/pubkey 　　查看一下 autossh 配置： uci&nbsp;get&nbsp;autossh.@autossh[0].ssh 　　如果没有问题，就把中转服务器的信息设置上去： uci set autossh.@autossh[0].ssh='-i /etc/dropbear/id_rsa -f -N -T -R 2222:localhost:22 &lt;user&gt;@&lt;cloud_ip&gt;'uci commit 　　接下来登录到中转服务器（Linux Server，如果是 OpenWRT，要把以下的 &nbsp;~/.ssh/authorized_keys 换成 /etc/dropbear/authorized_keys&nbsp;），把公钥（/tmp/pubkey）上传： echo&nbsp;"key&nbsp;内容"&nbsp;&gt;&gt;&nbsp;~/.ssh/authorized_keys#&nbsp;或者#cat&nbsp;pubkey&nbsp;&gt;&gt;&nbsp;~/.ssh/authorized_keyschmod&nbsp;0700&nbsp;~/.ssh/chmod&nbsp;0600&nbsp;~/.ssh/authorized_keysvi&nbsp;/etc/ssh/sshd_config#&nbsp;改为允许证书登录service&nbsp;sshd&nbsp;restart 　　/etc/ssh/sshd_config 需要打开的有：   RSAAuthentication yes  PubkeyAuthentication yes  AuthorizedKeysFile .ssh/authorized_keys  GatewayPorts yes  　　到路由器上测试： ssh&nbsp;-i&nbsp;/etc/dropbear/id_rsa&nbsp;-f&nbsp;-N&nbsp;-T&nbsp;-R&nbsp;2222:localhost:22&nbsp;&lt;user&gt;@&lt;cloud_ip&gt; 　　如果成功则大功告成，以后只需要 ssh 到中转服务器的 2222 端口就等于连接到路由器了。最后配合本地端口转发，可以连接很多内网机器了。如下图：  　　再加一台路由器，用于做本地端口转发，就可以让 Surface、iPad 之类的设备也能快乐地穿透到内网了。</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_295195" href="https://my.oschina.net/umu618/blog/295195">跟 UMU 一起玩 OpenWRT（入门篇11）：文件共享</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-07-27 00:52:14</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　文件共享可以通过 FTP、NFS、SAMBA，第一个需要先下载，无法“直接打开”，实用性比较差就不介绍了，重点放在 SAMBA，最后再简单介绍一下 NFS。 　　SAMBA 安装主要参考：http://wiki.openwrt.org/doc/uci/samba，或者中文介绍：http://www.leiphone.com/diy-a-smart-router-topic-share.html 的“安装 Windows 文件共享”章节。 　　如果配置后，无法正常访问，您可以参考一下《Windows 7 无法访问 NAS 或 Samba 服务器之解决》：http://www.win7china.com/html/5956.html。 　　NFS 和 SAMBA 是两大文件共享服务，NFS 在 Linux 设备之间的传输效率高于 SAMBA，路由器安装 NFS 服务端：http://wiki.openwrt.org/doc/howto/nfs.server；Windows 安装 NFS 客户端：http://www.cnblogs.com/itech/archive/2012/06/17/2552514.html。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_298649" href="https://my.oschina.net/umu618/blog/298649">增强 DIR-505 硬件</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-08-06 18:37:31</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　在《跟 UMU 一起玩 OpenWRT（入门篇3）：工作模式开关》中介绍了用 GPIO 读取工作模式开关，但外壳把第四个档位给挡住了，后来 UMU 经常用这个路由器做各种实验，感觉三个档位不够用了，于是就拿起了刻刀，手起刀落。 　　第一张是原始的：  　　手术后的：</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_309443" href="https://my.oschina.net/umu618/blog/309443">考题：关于子类调用父类构造函数</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-09-03 10:20:07</div>
                <div class='catalog'>分类：考题</div>
                                                                            </div>
            <div class='content'>class A{public:    A()    {    }    explicit A(int i)    {        i_ = i;    }    void Print()    {        printf_s("%d\n", i_);    }private:    int i_;};class B : public A{public:    B(int i)    {        A::A(i);    }};int _tmain(int argc, _TCHAR* argv[]){    B b(1234);    b.Print();    return 0;} 以上代码会打印出 1234 吗？ 当然不会……正确的写法如下： class A{public:    A()    {    }    explicit A(int i)    {        i_ = i;    }    void Print()    {        printf_s("%d\n", i_);    }private:    int i_;};class B : public A{public:    B(int i) : A(i)    {        //A::A(i);    }};int _tmain(int argc, _TCHAR* argv[]){    B b(1234);    b.Print();    return 0;} &nbsp; &nbsp; &nbsp;</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_347216" href="https://my.oschina.net/umu618/blog/347216">解决“输入个性化服务”InputPersonalization.exe 占用 CPU 过高的问题</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-11-21 15:09:39</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　最近遇到这个问题，导致 XPS15 的 CPU 过热，风扇狂转……查了一下又不少人都一样，比如：http://answers.microsoft.com/zh-hans/windows/forum/windows8_1-hardware/surface/82846637-0f42-4549-afc4-39e86faef77f   　　回想起以前遇到过类似问题：http://hi.baidu.com/umu618/item/36d0bbd57cc21395260ae706，立刻拿起 Process Explorer 查这个文件访问的文件，看到它访问了一个 InputPersonalization 文件夹下的文件，试着删掉这个文件夹，过去几个小时了，似乎是治好了……   　　具体路径：%LocalAppData%\Microsoft\InputPersonalization，删掉时会提示文件被 Windows Search 服务占用，您懂的，要 kill 这个服务的进程 SearchIndexer.exe。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_351007" href="https://my.oschina.net/umu618/blog/351007">通过 netlink 的 NETLINK_INET_DIAG 协议获取当前系统所有 TCP 连接信息</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-12-01 17:50:29</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　据说 ss 比 netstat 快，想研究一下原理，从这边看到代码：http://bbs.chinaunix.net/thread-3766684-1-1.html，但很不靠谱……整理了一下，供大家参考。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;asm/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;linux/inet_diag.h&gt;#include &lt;netinet/tcp.h&gt;int main(int argc, char **argv){    int fd;    struct sockaddr_nl src_addr, dest_addr;    struct    {        struct nlmsghdr nlh;        struct inet_diag_req r;    } req;    struct inet_diag_msg *pkg;    struct msghdr msg;    char buf[8192];    char src_ip[40];    char dest_ip[40];    struct iovec iov;    if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_INET_DIAG)) &lt; 0)        return -1;    int ret;    ret = fcntl(fd, F_SETFL, O_NONBLOCK);    if (ret &lt; 0) {        fprintf(stderr, "Can't set socket flags");        close(fd);        return -1;    }    //src addr    memset(&amp;src_addr, 0, sizeof(struct sockaddr_nl));    src_addr.nl_family = AF_NETLINK;    src_addr.nl_pid = getpid();    src_addr.nl_groups = 0;    if (bind(fd, (struct sockaddr *)&amp;src_addr, sizeof(struct sockaddr_nl)) &lt; 0) {        fprintf(stderr, "bind socket error %s\n", strerror(errno));    }    memset(&amp;req, 0, sizeof(req));    req.nlh.nlmsg_len = sizeof(req);    req.nlh.nlmsg_type = TCPDIAG_GETSOCK;    req.nlh.nlmsg_flags = NLM_F_MATCH | NLM_F_REQUEST | NLM_F_ROOT;    // req.nlh.nlmsg_flags = NLM_F_REQUEST ;    req.nlh.nlmsg_pid = 0;    memset(&amp;req.r, 0, sizeof(req.r));    req.r.idiag_family = AF_INET;    req.r.idiag_states = ((1 &lt;&lt; TCP_CLOSING + 1) - 1); //states to dump    //send msg to kernel    iov.iov_base = &amp;req;    iov.iov_len = sizeof(req);    //dest addr    memset(&amp;dest_addr, 0, sizeof(struct sockaddr_nl));    dest_addr.nl_family = AF_NETLINK;    dest_addr.nl_pid = 0;    dest_addr.nl_groups = 0;    msg.msg_name = (void *)&amp;dest_addr;    msg.msg_namelen = sizeof(dest_addr);    msg.msg_iov = &amp;iov;    msg.msg_iovlen = 1;    if (sendmsg(fd, &amp;msg, 0) &lt; 0) {        printf("%s\n", strerror(errno));        return -1;    }    //recv msg from kernel    iov.iov_base = buf;    iov.iov_len = sizeof(buf);    while (1) {        //printf("while1\n");        int status;        struct nlmsghdr *h;        msg = (struct msghdr)        {            (void *)&amp;dest_addr, sizeof(struct sockaddr_nl),                &amp;iov, 1, NULL, 0, 0        };        //length of recv data        status = recvmsg(fd, &amp;msg, 0);        //status = recv(fd, buf, sizeof(buf), 0);        printf("status = %d\n", status);        if (status &lt; 0) {            if (errno == EINTR) {                continue;            }            printf("errno = %d\n", errno);            continue;        }        if (status == 0) {            close(fd);            printf("EOF\n");            return 0;        }        h = (struct nlmsghdr *)buf;        while (NLMSG_OK(h, status)) {            //printf("while2\n");            if (h-&gt;nlmsg_type == NLMSG_DONE) {                close(fd);                printf("NLMSG_DONE\n");                return 0;            }            if (h-&gt;nlmsg_type == NLMSG_ERROR) {                struct nlmsgerr *err;                err = (struct nlmsgerr*)NLMSG_DATA(h);                fprintf(stderr, "%d Error %d:%s\n", __LINE__, -(err-&gt;error), strerror(-(err-&gt;error)));                close(fd);                printf("NLMSG_ERROR\n");                return 0;            }            pkg = (struct inet_diag_msg *)NLMSG_DATA(h);            memset(src_ip, 0, sizeof(src_ip));            memset(dest_ip, 0, sizeof(dest_ip));            inet_ntop(pkg-&gt;idiag_family, pkg-&gt;id.idiag_src, src_ip, sizeof(src_ip));            inet_ntop(pkg-&gt;idiag_family, pkg-&gt;id.idiag_dst, dest_ip, sizeof(dest_ip));            printf("%-8s %4d %40s:%-6hu %40s:%-6hu\n", pkg-&gt;idiag_family == AF_INET ? "AF_INET" : "AF_INET6", pkg-&gt;idiag_state                , src_ip, ntohs(pkg-&gt;id.idiag_sport), dest_ip, ntohs(pkg-&gt;id.idiag_dport));            // get_tcp_state(pkg-&gt;idiag_state);            h = NLMSG_NEXT(h, status);            //printf("status = %d\n\n", status);        }//while    }//while    close(fd);    return 0;} &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_352878" href="https://my.oschina.net/umu618/blog/352878">[UMU WSH 教程](46) 按图片拍摄时间批量重命名改进版</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-12-05 17:56:04</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>UMU WSH Git：http://git.oschina.net/umu618/umu-wsh   +文件内容对比，内容一样的删除其中一个。   +输出日志  ' 46_RenameImageToDateTime.VBS' UMU @ 16:33 2014/12/5' [UMU WSH 教程](46) WIA 和 WindowsInstaller 应用实例 - 按图片拍摄时间批量重命名并去重Option ExplicitConst APP_TITLE = "UMU.Script.Tools.RenameImageToDateTime+"Const APP_DESCRIPTION = "本程序用来把带 EXIF 信息的图片按拍摄时间批量重命名。"Const APP_USAGE = "请把要处理的文件或文件夹拖放到本程序的图标上！"Dim args, fso, wiSet args = WScript.ArgumentsSet fso = CreateObject("Scripting.FileSystemObject")Set wi = CreateObject("WindowsInstaller.Installer")If args.Count = 0 Then    Usage()Else    Dim is_move    Dim target_directory    Dim is_logging    Dim log_file    Dim succeeded_count, failed_count, exists_count    Main()End IfSet args = NothingSet fso = NothingSet wi = NothingPrivate Sub Usage()    Dim wsh    Dim send_to, copy_to    MsgBox APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE, vbInformation, APP_TITLE    Set wsh = CreateObject("WScript.Shell")    send_to = wsh.SpecialFolders("SendTo")    copy_to = send_to &amp; "\" &amp; APP_TITLE &amp; ".VBE"    Dim copy_to_sendto    If Not fso.FileExists(copy_to) Then        copy_to_sendto = True    ElseIf Not IsFileTheSame(copy_to, WScript.ScriptFullName) Then        copy_to_sendto = True    Else        copy_to_sendto = False    End If    If copy_to_sendto Then        If vbOK = MsgBox(APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE &amp; vbCrLf &amp; vbCrLf &amp; _            "提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。" &amp; vbCrLf &amp; _            "您的 Sendto 目录是 " &amp; send_to &amp; vbCrLf &amp; "按“确定”执行复制操作。", _            vbOKCancel + vbInformation, APP_TITLE) Then                        fso.CopyFile WScript.ScriptFullName, copy_to            If vbYes = MsgBox("是否查看 Sendto 目录？", vbQuestion + vbYesNo, APP_TITLE) Then                wsh.Run "%SystemRoot%\explorer.exe /n, /select," &amp; copy_to            End If        End If    End If    Set wsh = NothingEnd SubPrivate Sub Main()    is_move = MsgBox("重命名文件？按“否”复制文件，按“取消”退出！" &amp; vbCrLf &amp; "如果选择“是”则文件重复时，会删除多余文件。", vbYesNoCancel + vbQuestion, "询问")    If vbCancel = is_move Then        Exit Sub    End If    is_logging = MsgBox("产生日志？按“取消”退出！", vbYesNoCancel + vbQuestion, "询问")    If vbCancel = is_logging Then        Exit Sub    End If    If is_logging = vbYes Then        Set log_file = fso.CreateTextFile(fso.GetSpecialFolder(2) &amp; "\" &amp; APP_TITLE &amp; ".log")    End If    target_directory = InputBox("请输入存放目录：", "存放目录")    If Len(target_directory) = 0 Then        Exit Sub    End If    If Not fso.FolderExists(target_directory) Then        MsgBox target_directory, vbError, "存放目录不存在"        Exit Sub    End If    If Right(target_directory, 1) &lt;&gt; "\" Then        target_directory = target_directory &amp; "\"    End If    succeeded_count = 0    failed_count = 0    exists_count = 0    Dim ar    For Each ar In args        If fso.FolderExists(ar) Then            Call RenameImageToDateTime_s(ar)        ElseIf fso.FileExists(ar) Then            Call RenameImageToDateTime(ar)        End If    Next    If is_logging = vbYes Then        log_file.Close        Set log_file = Nothing    End If    MsgBox "重命名 " &amp; succeeded_count &amp; " 个，失败 " &amp; failed_count &amp; _        " 个，文件已经存在 " &amp; exists_count &amp; " 个！", 4160, "整个世界清净了！"End SubPrivate Sub RenameImageToDateTime_s(ByVal folder_path)    'On Error Resume Next    Dim rfd, fs, f, fds, fd    Set rfd = fso.GetFolder(folder_path)    Set fs = rfd.Files    For Each f In fs        Call RenameImageToDateTime(f.Path)    Next    Set fds = rfd.SubFolders    For Each fd In fds        Call RenameImageToDateTime_s(fd.Path)    NextEnd SubPrivate Sub RenameImageToDateTime(ByRef file_path)    'On Error Resume Next    Dim dt    dt = GetImageDateTime(file_path)    If Len(dt) &gt; 0 Then        Dim y, m        Dim path        y = Left(dt, 4)        m = Mid(dt, 6, 2)        path = target_directory &amp; y        If Not fso.FolderExists(path) Then            Call fso.CreateFolder(path)        End If        path = path &amp; "\" &amp; y &amp; "-" &amp; m        If Not fso.FolderExists(path) Then            Call fso.CreateFolder(path)        End If        If Err.Number &lt;&gt; 0 Then            failed_count = failed_count + 1            Err.Clear            Exit Sub        End If                Dim ext        ext = Mid(file_path, InStrRev(file_path, "."))        path = path &amp; "\" &amp; dt &amp; ext        If 0 = StrComp(file_path, path, vbTextCompare) Then            ' 路径一样，不做处理            exists_count = exists_count + 1            If is_logging = vbYes Then                log_file.WriteLine "=" &amp; file_path                log_file.WriteLine "="                log_file.WriteLine "----------------"            End If        ElseIf fso.FileExists(path) Then            exists_count = exists_count + 1            If IsFileTheSame(file_path, path) Then                fso.DeleteFile file_path                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "@" &amp; path                    log_file.WriteLine "----------------"                End If            Else                If is_logging = vbYes Then                    log_file.WriteLine file_path                    log_file.WriteLine "@" &amp; path                    log_file.WriteLine "----------------"                End If            End If        ElseIf vbYes = is_move Then            fso.MoveFile file_path, path            If Err.Number &lt;&gt; 0 Then                failed_count = failed_count + 1                Err.Clear                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "-" &amp; path                    log_file.WriteLine "----------------"                End If            Else                succeeded_count = succeeded_count + 1                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "+" &amp; path                    log_file.WriteLine "----------------"                End If            End If        Else            fso.CopyFile file_path, path            If Err.Number &lt;&gt; 0 Then                failed_count = failed_count + 1                Err.Clear                If is_logging = vbYes Then                    log_file.WriteLine "&amp;" &amp; file_path                    log_file.WriteLine "-" &amp; path                    log_file.WriteLine "----------------"                End If            Else                succeeded_count = succeeded_count + 1                If is_logging = vbYes Then                    log_file.WriteLine "&amp;" &amp; file_path                    log_file.WriteLine "+" &amp; path                    log_file.WriteLine "----------------"                End If            End If        End If    Else        ' 没有拍照日期        If is_logging = vbYes Then            log_file.WriteLine file_path            log_file.WriteLine "!"            log_file.WriteLine "----------------"        End If    End IfEnd SubPrivate Function GetImageDateTime(ByRef file_path)    On Error Resume Next    GetImageDateTime = ""    Dim image_file    Set image_file = CreateObject("WIA.ImageFile")    image_file.LoadFile file_path    If Err.Number &lt;&gt; 0 Then        ' 可能不是图像，或者图像格式无法识别        Exit Function    End If    Dim dt    Dim prop_names    Dim name    prop_names = Array("ExifDTOrig", "ExifDTDigitized", "DateTime")    For Each name In prop_names        If image_file.Properties.Exists(name) Then            Dim prop            Set prop = image_file.Properties(name)            dt = prop.Value            Set prop = Nothing            Exit For        End If    Next    Set image_file = Nothing    If Len(dt) &gt; 0 Then        dt = Replace(dt, "/", "-")        dt = Replace(dt, ":", "-")        dt = Replace(dt, " ", "_")        GetImageDateTime = dt    End IfEnd FunctionPrivate Function BigEndianHex(int)    Dim result    Dim b1, b2, b3, b4    result = Right("0000000" &amp; Hex(int), 8)    b1 = Mid(result, 7, 2)    b2 = Mid(result, 5, 2)    b3 = Mid(result, 3, 2)    b4 = Mid(result, 1, 2)    BigEndianHex = b1 &amp; b2 &amp; b3 &amp; b4End FunctionPrivate Function GetFileHash(ByRef file_name)    Dim file_hash    Dim hash_value    Dim i    Set file_hash = wi.FileHash(file_name, 0)    hash_value = ""    For i = 1 To file_hash.FieldCount        hash_value = hash_value &amp; BigEndianHex(file_hash.IntegerData(i))    Next    Set file_hash = Nothing    GetFileHash = hash_valueEnd FunctionPrivate Function IsFileTheSame(ByRef file1, ByRef file2)    If 0 = StrComp(file1, file2, vbTextCompare) Then        IsFileTheSame = True    Else        Dim hash1, hash2        hash1 = GetFileHash(file1)        hash2 = GetFileHash(file2)        If hash1 = hash2 And Len(hash1) &gt; 0 Then            IsFileTheSame = True        Else            IsFileTheSame = False        End If    End IfEnd Function      &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_352880" href="https://my.oschina.net/umu618/blog/352880">[UMU WSH 教程](47) FSO 应用实例 - 按文件最后修改时间批量重命名</a></h2>
            <div class='outline'>
                <div class='date'>时间：2014-12-05 17:58:14</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>UMU WSH Git：http://git.oschina.net/umu618/umu-wsh  ' 47_RenameFileByLastModifiedTime.VBS' UMU @ 0:21 2014/12/4' [UMU WSH 教程](47) FSO 应用实例 - 按文件最后修改时间批量重命名' Test code:' MsgBox WScript.ScriptFullName, , GetFileModifiedTime(WScript.ScriptFullName)Option ExplicitConst APP_TITLE = "UMU.Script.Tools.RenameFileByLastModifiedTime"Const APP_DESCRIPTION = "本程序用来把文件按最后修改时间批量重命名。"Const APP_USAGE = "请把要处理的文件或文件夹拖放到本程序的图标上！"Dim args, fso, wiSet args = WScript.ArgumentsSet fso = CreateObject("Scripting.FileSystemObject")Set wi = CreateObject("WindowsInstaller.Installer")If args.Count = 0 Then    Usage()Else    Dim is_move    Dim target_directory    Dim is_logging    Dim log_file    Dim succeeded_count, failed_count, exists_count    Main()End IfSet args = NothingSet fso = NothingSet wi = NothingPrivate Sub Usage()    Dim wsh    Dim send_to, copy_to    MsgBox APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE, vbInformation, APP_TITLE    Set wsh = CreateObject("WScript.Shell")    send_to = wsh.SpecialFolders("SendTo")    copy_to = send_to &amp; "\" &amp; APP_TITLE &amp; ".VBE"    Dim copy_to_sendto    If Not fso.FileExists(copy_to) Then        copy_to_sendto = True    ElseIf Not IsFileTheSame(copy_to, WScript.ScriptFullName) Then        copy_to_sendto = True    Else        copy_to_sendto = False    End If    If copy_to_sendto Then        If vbOK = MsgBox(APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE &amp; vbCrLf &amp; vbCrLf &amp; _            "提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。" &amp; vbCrLf &amp; _            "您的 Sendto 目录是 " &amp; send_to &amp; vbCrLf &amp; "按“确定”执行复制操作。", _            vbOKCancel + vbInformation, APP_TITLE) Then                        fso.CopyFile WScript.ScriptFullName, copy_to            If vbYes = MsgBox("是否查看 Sendto 目录？", vbQuestion + vbYesNo, APP_TITLE) Then                wsh.Run "%SystemRoot%\explorer.exe /n, /select," &amp; copy_to            End If        End If    End If    Set wsh = NothingEnd SubPrivate Sub Main()    is_move = MsgBox("重命名文件？按“否”复制文件，按“取消”退出！", vbYesNoCancel + vbQuestion, "询问")    If vbCancel = is_move Then        Exit Sub    End If    is_logging = MsgBox("产生日志？按“取消”退出！", vbYesNoCancel + vbQuestion, "询问")    If vbCancel = is_logging Then        Exit Sub    End If    If is_logging = vbYes Then        Set log_file = fso.CreateTextFile(fso.GetSpecialFolder(2) &amp; "\" &amp; APP_TITLE &amp; ".log")    End If    target_directory = InputBox("请输入存放目录：", "存放目录")    If Len(target_directory) = 0 Then        Exit Sub    End If    If Not fso.FolderExists(target_directory) Then        MsgBox target_directory, vbError, "存放目录不存在"        Exit Sub    End If    If Right(target_directory, 1) &lt;&gt; "\" Then        target_directory = target_directory &amp; "\"    End If    succeeded_count = 0    failed_count = 0    exists_count = 0    Dim ar    For Each ar In args        If fso.FolderExists(ar) Then            Call RenameFileByLastModifiedTime_s(ar)        ElseIf fso.FileExists(ar) Then            Call RenameFileByLastModifiedTime(ar)        End If    Next    If is_logging = vbYes Then        log_file.Close        Set log_file = Nothing    End If    MsgBox "重命名 " &amp; succeeded_count &amp; " 个，失败 " &amp; failed_count &amp; _        " 个，文件已经存在 " &amp; exists_count &amp; " 个！", 4160, "整个世界清净了！"End SubPrivate Sub RenameFileByLastModifiedTime_s(ByVal folder_path)    'On Error Resume Next    Dim rfd, fs, f, fds, fd    Set rfd = fso.GetFolder(folder_path)    Set fs = rfd.Files    For Each f In fs        Call RenameFileByLastModifiedTime(f.Path)    Next    Set fds = rfd.SubFolders    For Each fd In fds        Call RenameFileByLastModifiedTime_s(fd.Path)    NextEnd SubPrivate Sub RenameFileByLastModifiedTime(ByRef file_path)    'On Error Resume Next    Dim dt    dt = GetFileModifiedTime(file_path)    If Len(dt) &gt; 0 Then        Dim y, m        Dim path        y = Left(dt, 4)        m = Mid(dt, 6, 2)        path = target_directory &amp; y        If Not fso.FolderExists(path) Then            Call fso.CreateFolder(path)        End If        path = path &amp; "\" &amp; y &amp; "-" &amp; m        If Not fso.FolderExists(path) Then            Call fso.CreateFolder(path)        End If        If Err.Number &lt;&gt; 0 Then            failed_count = failed_count + 1            Err.Clear            Exit Sub        End If                Dim ext        ext = Mid(file_path, InStrRev(file_path, "."))        path = path &amp; "\" &amp; dt &amp; ext        If fso.FileExists(path) Then            exists_count = exists_count + 1            If IsFileTheSame(file_path, path) Then                fso.DeleteFile file_path                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "@" &amp; path                    log_file.WriteLine "----------------"                End If            Else                If is_logging = vbYes Then                    log_file.WriteLine file_path                    log_file.WriteLine "@" &amp; path                    log_file.WriteLine "----------------"                End If            End If        ElseIf vbYes = is_move Then            fso.MoveFile file_path, path            If Err.Number &lt;&gt; 0 Then                failed_count = failed_count + 1                Err.Clear                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "-" &amp; path                    log_file.WriteLine "----------------"                End If            Else                succeeded_count = succeeded_count + 1                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "+" &amp; path                    log_file.WriteLine "----------------"                End If            End If        Else            fso.CopyFile file_path, path            If Err.Number &lt;&gt; 0 Then                failed_count = failed_count + 1                Err.Clear                If is_logging = vbYes Then                    log_file.WriteLine "&amp;" &amp; file_path                    log_file.WriteLine "-" &amp; path                    log_file.WriteLine "----------------"                End If            Else                succeeded_count = succeeded_count + 1                If is_logging = vbYes Then                    log_file.WriteLine "&amp;" &amp; file_path                    log_file.WriteLine "+" &amp; path                    log_file.WriteLine "----------------"                End If            End If        End If    Else        ' 没有拍照日期        If is_logging = vbYes Then            log_file.WriteLine file_path            log_file.WriteLine "!"            log_file.WriteLine "----------------"        End If    End IfEnd SubPrivate Function TimeValue(num)    TimeValue = Right("0" &amp; num, 2)End FunctionPrivate Function MyFormatDateTime(ByRef dt)    MyFormatDateTime = Year(dt) &amp; "-" &amp; TimeValue(Month(dt)) &amp; "-" &amp; TimeValue(Day(dt)) &amp; "_" &amp; TimeValue(Hour(dt)) &amp; "-" &amp; TimeValue(Minute(dt)) &amp; "-" &amp; TimeValue(Second(dt))End FunctionPrivate Function GetFileModifiedTime(ByRef file_path)    On Error Resume Next    GetFileModifiedTime = ""    Dim file    Set file = fso.GetFile(file_path)    GetFileModifiedTime = MyFormatDateTime(file.DateLastModified)    Set file = NothingEnd FunctionPrivate Function BigEndianHex(int)    Dim result    Dim b1, b2, b3, b4    result = Right("0000000" &amp; Hex(int), 8)    b1 = Mid(result, 7, 2)    b2 = Mid(result, 5, 2)    b3 = Mid(result, 3, 2)    b4 = Mid(result, 1, 2)    BigEndianHex = b1 &amp; b2 &amp; b3 &amp; b4End FunctionPrivate Function GetFileHash(file_name)    Dim file_hash    Dim hash_value    Dim i    Set file_hash = wi.FileHash(file_name, 0)    hash_value = ""    For i = 1 To file_hash.FieldCount        hash_value = hash_value &amp; BigEndianHex(file_hash.IntegerData(i))    Next    Set file_hash = Nothing    GetFileHash = hash_valueEnd FunctionPrivate Function IsFileTheSame(ByRef file1, ByRef file2)    If 0 = StrComp(file1, file2, vbTextCompare) Then        IsFileTheSame = True    Else        Dim hash1, hash2        hash1 = GetFileHash(file1)        hash2 = GetFileHash(file2)        If hash1 = hash2 And Len(hash1) &gt; 0 Then            IsFileTheSame = True        Else            IsFileTheSame = False        End If    End IfEnd Function      &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494665" href="https://my.oschina.net/umu618/blog/494665">[UMU 学 golang](1) Hello code!</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-08-19 16:44:00</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'>　　一直玩 WSH，被说逼格跟不上时代，又据说 go 即将发布的 1.5 版解决了 GC stop-the-world 问题了，所以 UMU 打算以后用它来开发工具。　　最近想统计代码行数，以前用 VBS 写的一时间居然找不到，直接就用 golang 写了一个，基本从零开始用了大约 4 小时完成。下面谈一下心得。　　1、golang 的 runtime 居然没有 set，只能用 map 代替了，一开始觉得不优雅，不过想来也差不多，不计较那么多了。　　2、语法还确实挺简洁的，第一次练手就感觉学这个语言，其实是在学它的规范，语言本身太容易了。　　3、defer 挺好用的，简洁、省心，比如这个核心函数：func CountLine(path string) (num int) {f, err := os.Open(path)if nil != err {return}defer f.Close()s := bufio.NewScanner(f)for s.Scan() {num += 1}return}　　4、LiteIDE X 还比较好用，写 import 时，会自动按字母顺序排列库名，这样省得纠结顺序了……刚刚接触，就说到这里，最后附代码。// UMU @ 2015-08-17 11:30// Last update: 2015-08-17 17:01package mainimport ("bufio""fmt""os""path""path/filepath")func isSourceFile(ext string) bool {var kSourceFileExts = []string{".c", ".cc", ".cpp", ".h", ".hpp",".go",".java"}for _, r := range kSourceFileExts {if r == ext {return true}}return false}func main() {if len(os.Args) &lt; 2 {fmt.Println("Usage: ", os.Args[0], "[file or folder]...")return}files := make(map[string]bool)lines := 0for _, r := range os.Args {fi, err := os.Stat(r)if err == nil || os.IsExist(err) {if fi.IsDir() {AddDirectory(r, files)} else {AddFile(r, files)}}}for file, _ := range files {l := CountLine(file)lines += lfmt.Println(file, l)}fmt.Println("Total lines:", lines)}func AddDirectory(name string, files map[string]bool) {filepath.Walk(name, func(path string, fi os.FileInfo, err error) error {if nil == fi {return err}if fi.IsDir() {return nil}AddFile(path, files)return nil})return}func AddFile(name string, files map[string]bool) {ext := path.Ext(name)if isSourceFile(ext) {path, err := filepath.Abs(name)if err == nil {_, exists := files[path]if exists {fmt.Println("Duplicated", path)} else {files[path] = truefmt.Println("Add", path)}}}}func CountLine(path string) (num int) {f, err := os.Open(path)if nil != err {return}defer f.Close()s := bufio.NewScanner(f)for s.Scan() {num += 1}return}</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_495626" href="https://my.oschina.net/umu618/blog/495626">[UMU 学 golang](2) 升级 1.5 + 优化</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-08-21 19:18:39</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'>　　安装 1.5 时，直接覆盖 1.4.2，结果不能用了，报错：imports runtime: C source files not allowed when not using cgo or SWIG   　　解决方法是删掉 go 1.5……然后修复安装一遍。   　　优化：1、加了计时功能，纯属蛋疼。2、学到一个不占空间的 struct{}，map[string]bool 改为 map[string]struct{}。     // UMU @ 2015-08-17 11:30// Last update: 2015-08-21 17:40package mainimport ("bufio""fmt""os""path""path/filepath""time")func isSourceFile(ext string) bool {var kSourceFileExts = []string{".c", ".cc", ".cpp", ".h", ".hpp",".go",".java"}for _, r := range kSourceFileExts {if r == ext {return true}}return false}func main() {if len(os.Args) &lt; 2 {fmt.Println("Usage: ", os.Args[0], "[file or folder]...")return}start := time.Now()files := make(map[string]struct{})lines := 0for _, r := range os.Args {fi, err := os.Stat(r)if err == nil || os.IsExist(err) {if fi.IsDir() {AddDirectory(r, files)} else {AddFile(r, files)}}}for file, _ := range files {l := CountLine(file)lines += lfmt.Println(file, l)}fmt.Printf("Total lines: %d, cost %fs\n", lines, timeElapsed(start))}func AddDirectory(name string, files map[string]struct{}) {filepath.Walk(name, func(path string, fi os.FileInfo, err error) error {if nil == fi {return err}if fi.IsDir() {return nil}AddFile(path, files)return nil})}func AddFile(name string, files map[string]struct{}) {ext := path.Ext(name)if isSourceFile(ext) {path, err := filepath.Abs(name)if err == nil {_, exists := files[path]if exists {fmt.Println("Duplicated", path)} else {files[path] = struct{}{}fmt.Println("Add", path)}}}}func CountLine(path string) (num int) {f, err := os.Open(path)if nil != err {return}defer f.Close()s := bufio.NewScanner(f)for s.Scan() {num += 1}return}func timeElapsed(start time.Time) float64 {dis := time.Since(start).Seconds()return dis}</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_509647" href="https://my.oschina.net/umu618/blog/509647">[UMU 学 golang](3) TCP Echo Server</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-09-22 15:41:56</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'>　　测试需要，以前用 C + libevent 写了一个 TCP Echo Server，返回服务器时间、客户端地址信息和客户端发送的原内容。为了水一篇，现在改为 golang 实现。    package mainimport ("fmt""io""net""os""time")const BUFFER_SIZE = 1024 * 4var buffer = make([]byte, BUFFER_SIZE)func handleConnect(tcpConn *net.TCPConn) {if tcpConn == nil {return}for {n, err := tcpConn.Read(buffer)if err == io.EOF {fmt.Printf("The RemoteAddr: %s is closed!\n", tcpConn.RemoteAddr().String())return}handleError(err)if n &gt; 0 {//fmt.Printf("Read: %s", string(buffer[:n]))str := tcpConn.RemoteAddr().String() + " @ " +time.Now().Format("2006-01-02 15:04:05 Z07:00") + "\r\n" +string(buffer[:n])tcpConn.Write([]byte(str))fmt.Printf("Echo: %s", str)}}}// 错误处理func handleError(err error) {if err == nil {return}panic(err)//fmt.Printf("error: %s\n", err.Error())}func main() {if len(os.Args) &lt; 2 {fmt.Println("Usage:", os.Args[0], "&lt;port&gt;")return}port := os.Args[1]tcpAddr, err := net.ResolveTCPAddr("tcp4", "0.0.0.0:"+port)handleError(err)tcpListener, err := net.ListenTCP("tcp4", tcpAddr)handleError(err)defer tcpListener.Close()fmt.Println("Listening on", tcpAddr, "...")for {tcpConn, err := tcpListener.AcceptTCP()fmt.Printf("The client: %s has connected!\n", tcpConn.RemoteAddr().String())handleError(err)defer tcpConn.Close()go handleConnect(tcpConn)}}</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_510770" href="https://my.oschina.net/umu618/blog/510770">[UMU 学 golang](4) 简单的 AWS S3 客户端</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-09-24 17:24:28</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'>　　公司搞了一套兼容 Amazon S3 的云存储系统，用 C++ 写客户端很蛋疼，UMU 决定还是用 go 来写一个。　　首先找到一个靠谱的开源项目，运行以下命令安装：go get github.com/mitchellh/goamz　　它内部还用到了 github.com/vaughan0/go-ini。　　然后看一下例子：package mainimport (  "github.com/mitchellh/goamz/aws"  "github.com/mitchellh/goamz/s3"  "log"  "fmt")func main() {  auth, err := aws.EnvAuth()  if err != nil {    log.Fatal(err)  }  client := s3.New(auth, aws.USEast)  resp, err := client.ListBuckets()  if err != nil {    log.Fatal(err)  }  log.Print(fmt.Sprintf("%T %+v", resp.Buckets[0], resp.Buckets[0]))}　　要改的地方不多：1、认证方式可以改为 aws.GetAuth，但这样容易暴露 AccessKey、SecretKey，所以 UMU 下面贴出的代码还是使用 aws.EnvAuth()。2、aws.USEast 改为我们自己的。3、UMU 加了列出所有文件的功能。详见代码：package mainimport ("fmt""github.com/mitchellh/goamz/aws""github.com/mitchellh/goamz/s3""log")func main() {auth, err := aws.EnvAuth()if err != nil {log.Fatal(err)}var cnc = aws.Region{"cnc", // Name"",    // EC2Endpoint"http://s3.bj.xs3cnc.com", // S3Endpoint"",    // S3BucketEndpointfalse, // S3LocationConstraintfalse, // S3LowercaseBucket"",    // SDBEndpoint"",    // SNSEndpoint"",    // SQSEndpoint"",    // IAMEndpoint"",    // ELBEndpoint"",    // AutoScalingEndpoint"",    // RdsEndpoint"",    // Route53Endpoint}client := s3.New(auth, cnc)resp, err := client.ListBuckets()if err != nil {log.Fatal(err)}for _, b := range resp.Buckets {fmt.Printf("Bucket Name: %s\n", b.Name)bc, err := b.GetBucketContents()if err == nil {for _, key := range *bc {fmt.Printf("\t%s, %s, %d, %s, %s, %s\n",key.Key, key.LastModified, key.Size, key.StorageClass,key.Owner.ID, key.Owner.DisplayName)}}}}　　效果如下： 　　参照对象：</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_518047" href="https://my.oschina.net/umu618/blog/518047">[UMU 学 golang](5) HTTP Echo Server</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-10-16 15:19:11</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'>　　做加速时经常需要用到 HTTP Echo Server 来测试加速有没有成功，如果成功了，是显示请求来自加速代理服务器。原来用 node.js 写了一个，代码如下：        var http = require('http');http.createServer(    function (req, res) {        res.writeHead(200, {'Content-Type': 'text/plain'});        var ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress || req.connection.socket.remoteAddress;        var ua = req.headers['user-agent'];        res.end(ip + '\n' + ua);    }).listen(80);console.log('Server is running...');  　　现在改为 golang，并稍微改进了一下：    package mainimport ("fmt""net/http""os""time")func main() {var addr stringif len(os.Args) &gt; 1 {addr = ":" + os.Args[1]} else {addr = ":80"}server := http.Server{Addr:        addr,Handler:     &amp;MyHandler{},ReadTimeout: 5 * time.Second,}err := server.ListenAndServe()fmt.Println(err)}type MyHandler struct{}func (*MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {info := r.RemoteAddr + " @ " + time.Now().String() + "\r\n" +r.Method + " " + r.RequestURI + "\r\n" +"Host: " + r.Host + "\r\n" +"UserAgent: " + r.UserAgent() + "\r\n"w.Write([]byte(info))fmt.Println(info)}</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_542206" href="https://my.oschina.net/umu618/blog/542206">newifi mini 刷 OpenWRT</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-12-10 16:33:42</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　newifi mini，即 lenovo Y1，属于不开放 SSH 的类型，越用越不爽，还是刷了吧。　　先到 http://www.xcloud.cc/download.shtml 下载“路由助手”，然后到 OpenWRT 官网下载 ROM，推荐用 trunk 上的（目前是 dd），因为 bb 和 cc 都没有集成 kmod-mt76（当然你自己手动安装是可以的，opkg install kmod-mt76），下载链接：http://downloads.openwrt.org/snapshots/trunk/ramips/mt7620/openwrt-ramips-mt7620-y1-squashfs-sysupgrade.bin。目前刷完是 OpenWrt Designated Driver r47548，5G WiFi 没问题。　　由于是 trunk 版，luci 要自己装了，请参考之前的文章《跟 UMU 一起玩 OpenWRT（入门篇7）：安装 LUCI》，链接：http://my.oschina.net/umu618/blog/284552 　　存在几个问题：1、刷完，三个网口顺序和原版是颠倒的。2、5G WiFi 设置参数后似乎没有办法立刻生效，UMU 都是 reboot 一下解决。</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_542900" href="https://my.oschina.net/umu618/blog/542900">从“批量导出 QQ 空间说说脚本”的进化谈腾讯对安全性的重视</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-12-11 16:15:08</div>
                <div class='catalog'>分类：业余作品</div>
                                                                            </div>
            <div class='content'>　　2015-03-16 为了导出自己的说说，第一次写了这个脚本，感觉很容易，就是用 WP 的浏览器登录 m.qzone.com，抓包分析，然后写个 js 调用 WinHttp.WinHttpRequest.5.1 反复请求，直到说说下载完毕。这个时候的权限验证只需要一个 sid 就行了，刷刷地，很快就下载了 7 年的说说，赫赫。   　　2015-09-07 发现之前的脚本失效了，参数有点变化，但很快又跟进。   　　2015-11-27 又失效了，除了 json 字段有变化，还增加了对 Cookie 的验证，于是又加上了 Cookie 的模拟。   　　2015-12-11 又又失效了，这次增加了对 UserAgent 的验证……好蛋疼的感觉，继续跟进。   　　结论：腾讯很看重安全性！</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_546767" href="https://my.oschina.net/umu618/blog/546767">吐槽一下 Surface 的扩展坞</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-12-17 14:26:44</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　UMU 买了 Surface Pro 3 和 Surface Pro 4 的扩展坞各一个，在公司和家里混用时就发现了一个不太妙的情况：两个不同的扩展坞，理论上他们的网卡也应该是不同的，实际测试 MAC 地址确实也是不同的，然后实际上它们在 Windows 里都被映射为一个叫 Surface Ethernet Adapter 的网卡，是一个，是一个，是一个！！！　　这样的机制感觉挺不合理的，比如公司的网络是绑定固定的&nbsp;IP-MAC 地址的，家里是 DHCP 的，结果要反复修改 IP，虽然稣写了一个自动修改 IP 的脚本，但如果两个扩展坞是映射为两张不同的网卡，问题不就不存在了吗？　　难道要把家里的路由器改成和公司一样的网段？蛋疼啊！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_546917" href="https://my.oschina.net/umu618/blog/546917">如何比较两个文件是否一样？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2015-12-17 17:45:35</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>　　如何比较两个文件是否一样？是两个文件，两个文件，两个文件，这里是基于二进制比较的。　　太简单了，首先比较文件大小，大小不一样一定不一样。　　如果大小一样，就打开对比字节流，实现可能是一个循环，每次读取 8K 字节，然后按顺序对比，只要有不同就返回不同，直到全部比较完了都没有不同，那就是相同了。　　好简单啊……不如来点逼格？UMU 看到有人是对两个文件取了 MD5 hash，然后比较 hash 是否相等……　　开喷！　　1、MD5 有碰撞问题……有可能不同的文件，hash 出来是一样的，即存在误判的可能。　　2、这效率会耗在计算 hash 上，事实上如果文件不一样，极可能不需要读取整个文件就可以发现不同的，而算 hash 是一定要把文件都读完的。　　总之，咳咳，还是用前面的方法好，hash 的方式适合用于文件很多，很多，很多，每两个之间都要对比的情况，请参考《[UMU WSH 教程](44) WII 应用实例 - 查找重复文件》：http://my.oschina.net/umu618/blog/133901。只有两个，两个，两个对比的情况，请不要装逼，就直接对比，直接对比，直接对比。 　　装逼和优化都需要谨慎！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_613182" href="https://my.oschina.net/umu618/blog/613182">[UMU WSH 教程终结篇](48) FSO 应用实例 - 批量重命名 WP 视频</a></h2>
            <div class='outline'>
                <div class='date'>时间：2016-02-02 23:34:50</div>
                <div class='catalog'>分类：WSH</div>
                                                                            </div>
            <div class='content'>UMU WSH Git：http://git.oschina.net/umu618/umu-wsh/ 本篇为 UMU WSH 教程终结篇，以后更倾向使用 Windows PowerShell 和 golang 来编写工具。早期 WP 拍摄的视频，命名格式为 WP_YYYYMMDD_xxx.mp4，丢失了拍摄的时间，后来的版本是 WP_YYYYMMDD_HH_mm_SS_Pro.mp4，这才是满意的格式，所以特地写了这个脚本，将早期的 WP&nbsp;自动按 LastModified 时间命名为 YYYY-MM-DD_HH-mm-SS.mp4 的格式。直接看代码吧！   ' 48_RenameWPVideoByLastModifiedTime.VBS' UMU @ 15:40 2016/01/20' [UMU WSH 教程](48) FSO 应用实例 - 按文件最后修改时间批量重命名 WP 视频文件Option ExplicitConst APP_TITLE = "UMU.Script.Tools.RenameWPVideoByLastModifiedTime"Const APP_DESCRIPTION = "本程序用来把 WP 视频文件按最后修改时间批量重命名。"Const APP_USAGE = "请把要处理的文件或文件夹拖放到本程序的图标上！"Const OLD_TIME = #1900/01/01 00:00:00#Dim args, fso, wiSet args = WScript.ArgumentsSet fso = CreateObject("Scripting.FileSystemObject")Set wi = CreateObject("WindowsInstaller.Installer")If args.Count = 0 Then    Usage()Else    Dim is_move    Dim is_logging    Dim log_file    Dim succeeded_count, failed_count, exists_count    Main()End IfSet args = NothingSet fso = NothingSet wi = NothingPrivate Sub Usage()    Dim wsh    Dim send_to, copy_to    MsgBox APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE, vbInformation, APP_TITLE    Set wsh = CreateObject("WScript.Shell")    send_to = wsh.SpecialFolders("SendTo")    copy_to = send_to &amp; "\" &amp; APP_TITLE &amp; ".VBE"    Dim copy_to_sendto    If Not fso.FileExists(copy_to) Then        copy_to_sendto = True    ElseIf Not IsFileTheSame(copy_to, WScript.ScriptFullName) Then        copy_to_sendto = True    Else        copy_to_sendto = False    End If    If copy_to_sendto Then        If vbOK = MsgBox(APP_DESCRIPTION &amp; vbCrLf &amp; APP_USAGE &amp; vbCrLf &amp; vbCrLf &amp; _            "提示：您可以把此文件放在 Sendto 目录里，然后使用右键菜单的“发送到”。" &amp; vbCrLf &amp; _            "您的 Sendto 目录是 " &amp; send_to &amp; vbCrLf &amp; "按“确定”执行复制操作。", _            vbOKCancel + vbInformation, APP_TITLE) Then            fso.CopyFile WScript.ScriptFullName, copy_to            If vbYes = MsgBox("是否查看 Sendto 目录？", vbQuestion + vbYesNo, APP_TITLE) Then                wsh.Run "%SystemRoot%\explorer.exe /n, /select," &amp; copy_to            End If        End If    End If    Set wsh = NothingEnd SubPrivate Sub Main()    is_move = MsgBox("重命名文件？按“否”复制文件，按“取消”退出！", vbYesNoCancel + vbQuestion, "询问")    If vbCancel = is_move Then        Exit Sub    End If    is_logging = MsgBox("产生日志？按“取消”退出！", vbYesNoCancel + vbQuestion, "询问")    If vbCancel = is_logging Then        Exit Sub    End If    If is_logging = vbYes Then        Set log_file = fso.CreateTextFile(fso.GetSpecialFolder(2) &amp; "\" &amp; APP_TITLE &amp; ".log")    End If    succeeded_count = 0    failed_count = 0    exists_count = 0    Dim ar    For Each ar In args        If fso.FolderExists(ar) Then            Call RenameWPVideoByLastModifiedTime_s(ar)        ElseIf fso.FileExists(ar) Then            Call RenameWPVideoByLastModifiedTime(ar)        End If    Next    If is_logging = vbYes Then        log_file.Close        Set log_file = Nothing    End If    MsgBox "重命名 " &amp; succeeded_count &amp; " 个，失败 " &amp; failed_count &amp; _        " 个，文件已经存在 " &amp; exists_count &amp; " 个！", 4160, "整个世界清净了！"End SubPrivate Sub RenameWPVideoByLastModifiedTime_s(ByVal folder_path)    'On Error Resume Next    Dim rfd, fs, f, fds, fd    Set rfd = fso.GetFolder(folder_path)    Set fs = rfd.Files    For Each f In fs        Call RenameWPVideoByLastModifiedTime(f.Path)    Next    Set fds = rfd.SubFolders    For Each fd In fds        Call RenameWPVideoByLastModifiedTime_s(fd.Path)    NextEnd SubPrivate Sub RenameWPVideoByLastModifiedTime(ByRef file_path)    'On Error Resume NextDim path_posDim file_namepath_pos = InStrRev(file_path, "\")file_name = Mid(file_path, path_pos + 1)If 0 &lt;&gt; StrComp(Left(file_name, 3), "WP_", vbBinaryCompare) Then' 不是 WP_ 开头，跳过Exit SubEnd IfIf 0 &lt;&gt; StrComp(Right(file_name, 4), ".mp4", vbTextCompare) Then' 不是 .MP4，跳过Exit SubEnd IfIf 19 &lt;&gt; Len(file_name) Then' WP 视频命名有两种：WP_YYYYMMDD_HH_mm_SS_Pro.mp4（28）' WP_YYYYMMDD_xxx.mp4（19）,前者不需要处理' 文件名太长，跳过Exit SubEnd IfDim date_partdate_part = Mid(file_name, 4, 8)If Not IsNumeric(date_part) Then' 不是日期格式的数字Exit SubEnd If    Dim date_time    date_time = GetFileModifiedTime(file_path)    If date_time &gt; OLD_TIME ThenDim dtdt = MyFormatDateTime(date_time)If 0 &lt;&gt; StrComp(date_part, MyFormatDate(date_time)) ThenIf is_logging = vbYes Thenlog_file.WriteLine file_pathlog_file.WriteLine "#" &amp; dtlog_file.WriteLine "----------------"End IfExit SubEnd If        Dim path        path = Left(file_path, path_pos)        Dim ext        ext = Mid(file_path, InStrRev(file_path, "."))        path = path &amp; dt &amp; ext        If fso.FileExists(path) Then            exists_count = exists_count + 1            If IsFileTheSame(file_path, path) Then                fso.DeleteFile file_path                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "@" &amp; path                    log_file.WriteLine "----------------"                End If            Else                If is_logging = vbYes Then                    log_file.WriteLine file_path                    log_file.WriteLine "@" &amp; path                    log_file.WriteLine "----------------"                End If            End If        ElseIf vbYes = is_move Then            fso.MoveFile file_path, path            If Err.Number &lt;&gt; 0 Then                failed_count = failed_count + 1                Err.Clear                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "-" &amp; path                    log_file.WriteLine "----------------"                End If            Else                succeeded_count = succeeded_count + 1                If is_logging = vbYes Then                    log_file.WriteLine "~" &amp; file_path                    log_file.WriteLine "+" &amp; path                    log_file.WriteLine "----------------"                End If            End If        Else            fso.CopyFile file_path, path            If Err.Number &lt;&gt; 0 Then                failed_count = failed_count + 1                Err.Clear                If is_logging = vbYes Then                    log_file.WriteLine "&amp;" &amp; file_path                    log_file.WriteLine "-" &amp; path                    log_file.WriteLine "----------------"                End If            Else                succeeded_count = succeeded_count + 1                If is_logging = vbYes Then                    log_file.WriteLine "&amp;" &amp; file_path                    log_file.WriteLine "+" &amp; path                    log_file.WriteLine "----------------"                End If            End If        End If    Else        ' 没有最后修改时间        If is_logging = vbYes Then            log_file.WriteLine file_path            log_file.WriteLine "!"            log_file.WriteLine "----------------"        End If    End IfEnd SubPrivate Function TimeValue(num)    TimeValue = Right("0" &amp; num, 2)End FunctionPrivate Function MyFormatDateTime(ByRef dt)    MyFormatDateTime = Year(dt) &amp; "-" &amp; TimeValue(Month(dt)) &amp; "-" &amp; TimeValue(Day(dt)) &amp; "_" &amp; TimeValue(Hour(dt)) &amp; "-" &amp; TimeValue(Minute(dt)) &amp; "-" &amp; TimeValue(Second(dt))End FunctionPrivate Function MyFormatDate(ByRef dt)    MyFormatDate = Year(dt) &amp; TimeValue(Month(dt)) &amp; TimeValue(Day(dt))End FunctionPrivate Function GetFileModifiedTime(ByRef file_path)    On Error Resume Next    GetFileModifiedTime = OLD_TIME    Dim file    Set file = fso.GetFile(file_path)    GetFileModifiedTime = file.DateLastModified    Set file = NothingEnd FunctionPrivate Function BigEndianHex(int)    Dim result    Dim b1, b2, b3, b4    result = Right("0000000" &amp; Hex(int), 8)    b1 = Mid(result, 7, 2)    b2 = Mid(result, 5, 2)    b3 = Mid(result, 3, 2)    b4 = Mid(result, 1, 2)    BigEndianHex = b1 &amp; b2 &amp; b3 &amp; b4End FunctionPrivate Function GetFileHash(file_name)    Dim file_hash    Dim hash_value    Dim i    Set file_hash = wi.FileHash(file_name, 0)    hash_value = ""    For i = 1 To file_hash.FieldCount        hash_value = hash_value &amp; BigEndianHex(file_hash.IntegerData(i))    Next    Set file_hash = Nothing    GetFileHash = hash_valueEnd FunctionPrivate Function IsFileTheSame(ByRef file1, ByRef file2)    If 0 = StrComp(file1, file2, vbTextCompare) Then        IsFileTheSame = True    Else        Dim hash1, hash2        hash1 = GetFileHash(file1)        hash2 = GetFileHash(file2)        If hash1 = hash2 And Len(hash1) &gt; 0 Then            IsFileTheSame = True        Else            IsFileTheSame = False        End If    End IfEnd Function</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_667305" href="https://my.oschina.net/umu618/blog/667305">Lenovo Y1S 千兆 LAN 改 WAN</a></h2>
            <div class='outline'>
                <div class='date'>时间：2016-04-28 00:34:07</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　需求：把两个千兆 LAN 其中一个改为 WAN。　　UMU 一开始直接在官方 ROM 上去改 switch 的方式，发现不行，因为原 WAN&nbsp;口废掉了，如果不插着网线，官方 ROM 会很智能地以为路由器是没上网的，所以一直重定向到设置页面，让你烦死。　　尝试修改 /etc/config/system 还是没解决，所以……直接刷 OpenWRT 吧……请参考：《newifi mini 刷 OpenWRT》http://my.oschina.net/umu618/blog/542206，ROM 下载地址：https://downloads.openwrt.org/snapshots/trunk/ramips/mt7620/openwrt-ramips-mt7620-y1s-squashfs-sysupgrade.bin　　刷完再改 switch 瞬间就搞定了，还是 OpenWRT 用得爽啊。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_668303" href="https://my.oschina.net/umu618/blog/668303">OpenWRT PPTP VPN 穿透</a></h2>
            <div class='outline'>
                <div class='date'>时间：2016-04-29 21:58:43</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　刷了 OpenWRT trunk 版本后默认是不支持 PPTP VPN passthrough 的，表现为 PC 在 OpenWRT 路由器子网内，拨号时认证很快就过了，但迟迟不能完成，最终报错误码 619，这是因为默认不支持 GRE 协议的 NAT。   　　官方就有解决方案：https://wiki.openwrt.org/doc/howto/vpn.nat.pptp，简单地说是运行一下两条：  opkg updateopkg install kmod-nf-nathelper-extra 　　立刻生效。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_678118" href="https://my.oschina.net/umu618/blog/678118">VS2015 集成 YASM 1.3</a></h2>
            <div class='outline'>
                <div class='date'>时间：2016-05-19 17:16:35</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>系统：Windows 10IDE：VS2015任务：集成 YASM 1.3官网：http://yasm.tortall.net/Download.html照做后，得到一个错误：error MSB3721: The command "......" exited with code 1.直接跑命令则提示：vsyasm: FATAL: unrecognized object format `Win32'原因：区分大小写……应该用 win32 而不是 Win32，您可以改一下工程平台的名字，但默认都是 Win32，不太方便，所以我们要对 vsyasm.props 进行改造：&lt;CommandLineTemplate&gt;"$(YasmPath)"vsyasm.exe -Xvc -f $(Platform) [AllOptions] [AdditionalOptions] [Inputs]&lt;/CommandLineTemplate&gt;替换为：&lt;CommandLineTemplate&gt;"$(YasmPath)vsyasm.exe" -Xvc -f $(Platform.ToLower()) [AllOptions] [AdditionalOptions] [Inputs]&lt;/CommandLineTemplate&gt;或者：&lt;CommandLineTemplate&gt;"$(YasmPath)vsyasm.exe" -Xvc -f win$(PlatformArchitecture) [AllOptions] [AdditionalOptions] [Inputs]&lt;/CommandLineTemplate&gt;保存即搞定，连 VS 都不需要重启。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_681357" href="https://my.oschina.net/umu618/blog/681357">一次 dropbear 和 openssh 冲突的经历</a></h2>
            <div class='outline'>
                <div class='date'>时间：2016-05-26 10:12:44</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>任务：在 OpenWRT 路由器 C 用公钥验证方式登录另一台 OpenWRT 路由器 S。现象：一开始配置完很顺利登录，后来进行一些操作后，居然登录不了了，提示输入密码……类似情况：https://github.com/rssnsj/openwrt-hc5x61/issues/99&nbsp;　　一开始也以为是 OpenWRT 版本的问题，从 dd trunk&nbsp;降到 cc，无用。再降到 bb，发现没问题了，因为 bb 没有 sshtunnel，最后把怀疑对象锁定到 sshtunnel。　　sshtunnel 是基于 openssh 的，在装 sshtunnel 时，openssh 会作为依赖项被装上，然后替换了系统自带的 dropbear 客户端，所以后来使用的 ssh 是 openssh，但私钥文件却是一开始用 dropbearkey 产生的……两者并不兼容。　　正确的做法是：装上 openssh-keygen，然后用 ssh-keygen 产生新的私钥，再用 ssh-keygen -y -f ~/.ssh/id_rsa 打印公钥。&nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_818839" href="https://my.oschina.net/umu618/blog/818839">[C++ 学习笔记 1] delete 和 delete [] 的本质区别</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-04 23:25:53</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>　　之前只系统学过 C，自然地了解了一些 C++ 的皮毛（可以认为是 C+），然后就一直用着 C+ 开发，最近看了一些现代 C++ 代码，感觉是时候好好学习 C++ 了……后续会把学习中记的笔记发出来，尽量简短明了。 　　当 ptr 指向的是基础类型数组时，delete ptr 和 delete [] ptr 等价。这好比用 free 释放 malloc 分配的内存，malloc 了多少，不必关心，free 知道要释放多长，因为 malloc 会维护这个长度信息。 　　当 ptr 指向类对象数组时，两者的差别在于调用多少个析构函数，delete 只调用第一个元素的析构函数，delete [] 则调用所有元素的析构函数。 #include &lt;memory&gt;#include &lt;iostream&gt;class Foo{public:    Foo()    {        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    }    ~Foo()    {        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    }};int main(){    // bug: 只会析构一个元素    std::shared_ptr&lt;Foo&gt; p(new Foo[10]);    return 0;} &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_819390" href="https://my.oschina.net/umu618/blog/819390">[C++ 学习笔记 2] 为什么会有移动构造函数、std::move？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-05 17:30:26</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>UMU 认为是为了：需求细分。考虑以下代码： class Movable{public:Movable() : i(new int(3)){std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;}Movable(Movable&amp; m) : i(m.i){m.i = nullptr; // 这里改变值是可以的std::cout &lt;&lt; __FUNCTION__ &lt;&lt; "&amp;" &lt;&lt; std::endl;}int* i;}; 因为 Movable&amp; m 没有用 const 修饰，所以可以在内部改变 m 的状态。如果加上 const 则不行： Movable(const Movable&amp; m) : i(m.i){//m.i = nullptr; // 不能改变 mstd::cout &lt;&lt; __FUNCTION__ &lt;&lt; "&amp;" &lt;&lt; std::endl;} 那么没加 const 的集合，减去有 const 的集合，等于什么？答案就是：移动构造函数 Movable(Movable&amp;&amp; m) : i(m.i){m.i = nullptr;std::cout &lt;&lt; __FUNCTION__ &lt;&lt; "&amp;&amp;" &lt;&lt; std::endl;} 分成 const Movable&amp; 和 Movable&amp;&amp; 两个，更严格、更清晰，这是好事。而 std::move 做的事情是为了正确调用移动构造函数（Movable&amp;&amp;），而不是被隐式转为 const 而错误地调用了复制构造函数（const Movable&amp;），不要在意什么左值、右值的，太烧脑了…… 扩展阅读：《从4行代码看右值引用》，http://www.cnblogs.com/qicosmos/p/4283455.html &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_819862" href="https://my.oschina.net/umu618/blog/819862">[C++ 学习笔记 3] std::make_shared 和 std::enable_shared_from_this</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-06 12:28:04</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>看 asio 范例 async_tcp_echo_server.cpp 的过程学习到不少东西。 //// async_tcp_echo_server.cpp// ~~~~~~~~~~~~~~~~~~~~~~~~~//// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)//// Distributed under the Boost Software License, Version 1.0. (See accompanying// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)//#include "stdafx.h"#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;utility&gt;#include "asio.hpp"using asio::ip::tcp;class session: public std::enable_shared_from_this&lt;session&gt;// UMU: enable_shared_from_this 是为了在类内部使用指向自己的 shared_ptr{public:session(tcp::socket socket): socket_(std::move(socket)){}void start(){do_read();}private:void do_read(){auto self(shared_from_this());// UMU: 捕获 this 是为了在 lambda 表达式里调用 do_write// UMU: 捕获 self 是为了在 lambda 表达式里引用它，增加引用计数器，防止未调用 lambda 函数前被释放socket_.async_read_some(asio::buffer(data_, max_length),[this, self](std::error_code ec, std::size_t length){if (!ec) {do_write(length);// UMUstd::cout.write(data_, length);std::cout &lt;&lt; std::endl &lt;&lt; std::endl;}});}void do_write(std::size_t length){auto self(shared_from_this());asio::async_write(socket_, asio::buffer(data_, length),[this, self](std::error_code ec, std::size_t /*length*/){if (!ec) {do_read();}});}tcp::socket socket_;enum { max_length = 1024 };char data_[max_length];};class server{public:server(asio::io_service&amp; io_service, short port): acceptor_(io_service, tcp::endpoint(tcp::v4(), port)),socket_(io_service){do_accept();}private:void do_accept(){acceptor_.async_accept(socket_,[this](std::error_code ec){if (!ec) {// UMU: std::move 是为了调用移动构造函数// UMU: std::make_shared 是为了包装 new 对象和 new shared_ptr，使这两个 new 都控制在 make_shared 内部，这样如果任何一个 new 失败，都可以正确释放std::make_shared&lt;session&gt;(std::move(socket_))-&gt;start();}do_accept();});}tcp::acceptor acceptor_;tcp::socket socket_;};int main(int argc, char* argv[]){try {if (argc != 2) {std::cerr &lt;&lt; "Usage: async_tcp_echo_server &lt;port&gt;\n";return 1;}asio::io_service io_service;server s(io_service, std::atoi(argv[1]));io_service.run();} catch (std::exception&amp; e) {std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n";}return 0;} 代码中的 self 只被 lambda 表达式捕获，在匿名函数体内部并没有被显式使用，但它是有被隐式引用到的，如果去掉对 self 的捕获，则在收到数据时，会发现 socket_ 已经失效了。 参考文章   《make_shared和shared_ptr的区别》http://www.tuicool.com/articles/F3u6jy  《std::enable_shared_from_this 有什么意义？https://www.zhihu.com/question/30957800  《c++11 条款21：尽量使用std::make_unique和std::make_shared而不直接使用new》http://blog.csdn.net/coolmeme/article/details/43405155  &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_821720" href="https://my.oschina.net/umu618/blog/821720">[C++ 学习笔记 4] Duff's Device（switch 和 for 穿插）</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-09 23:36:52</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>看了 asio 的 \src\tests\latency\tcp_server.cpp 代码，被 coroutine 的 reenter 和 yield 的实现给震精到了……switch 和 for 穿插着，这居然也行，还有个学名叫“Duff's Device”！赶快写个测试代码，证明它是对的： void foo(int n){printf_s("---- %d ----\n", n);switch (n) {for (;;)case 0:if (1) {printf_s("0\n");break;} elsecase 1:printf_s("1\n");break;default:printf_s("default\n");break;}}int main(){foo(0);foo(1);return 0;} 顺利编译，输出是：   ---- 0 ---- 0 ---- 1 ---- 1 0  好像不容易看懂，但是加上一些&nbsp;{} 就容易了： void foo(int n){printf_s("---- %d ----\n", n);switch (n) {for (;;) {case 0:if (1) {printf_s("0\n");break;} else {case 1:printf_s("1\n");}}break;default:printf_s("default\n");break;}} 大神的代码不容置疑，以下代码追求减少循环测试的执行次数。 void duff_memcpy(char* to, char* from, size_t count){size_t n = (count + 7) / 8;switch (count % 8) {case 0: do { *to++ = *from++;case 7: *to++ = *from++;case 6: *to++ = *from++;case 5: *to++ = *from++;case 4: *to++ = *from++;case 3: *to++ = *from++;case 2: *to++ = *from++;case 1: *to++ = *from++;} while (--n &gt; 0);}} 第一轮用 switch 选择进入点，以后每轮都是复制 8 字节。 扩展阅读： 《Asio 协程详解》https://www.avboost.com/t/asio/771 &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_827203" href="https://my.oschina.net/umu618/blog/827203">[C++ 学习笔记 5] 搞定 asio coroutine 示例</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-18 16:36:46</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>前几天在 Windows 编译了 asio-1.10.8\src\tests\latency\tcp_server.cpp，结果并不能正常工作，客户端连上来，发数据后就卡死了…… 今天，重新思考用 aiso coroutine 来写个 echo server 练手，终于把这个 bug 解决了，具体见注释。 #include &lt;asio/io_service.hpp&gt;#include &lt;asio/ip/tcp.hpp&gt;#include &lt;asio/read.hpp&gt;#include &lt;asio/write.hpp&gt;#include &lt;asio/yield.hpp&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using asio::ip::tcp;class tcp_server : asio::coroutine{public:tcp_server(tcp::acceptor&amp; acceptor, std::size_t buf_size) :acceptor_(acceptor),socket_(acceptor_.get_io_service()),buffer_(buf_size){}void operator()(asio::error_code ec, std::size_t n = 0){reenter(this) for (;;) {yield acceptor_.async_accept(socket_, ref(this));if (ec) {std::cout &lt;&lt; "[" &lt;&lt; ec.value() &lt;&lt; "]" &lt;&lt; ec.message() &lt;&lt; std::endl;} else {std::cout &lt;&lt; "Connect from " &lt;&lt; socket_.remote_endpoint() &lt;&lt; std::endl;}while (!ec) {// UMU: 下一行是 bug，会卡死！！！//yield asio::async_read(socket_, asio::buffer(buffer_), ref(this));yield socket_.async_read_some(asio::buffer(buffer_), ref(this));if (ec) {// UMUstd::cout &lt;&lt; "[" &lt;&lt; ec.value() &lt;&lt; "]" &lt;&lt; ec.message() &lt;&lt; std::endl;} else {std::cout &lt;&lt; "Read " &lt;&lt; n &lt;&lt; " from " &lt;&lt; socket_.remote_endpoint() &lt;&lt; ": ";std::cout.write(reinterpret_cast&lt;char *&gt;(buffer_.data()), n);std::cout &lt;&lt; std::endl;// UMU: 下面两种写法都可以//yield asio::async_write(socket_, asio::buffer(buffer_, n), ref(this));yield socket_.async_write_some(asio::buffer(buffer_, n), ref(this));if (ec) {std::cout &lt;&lt; "[" &lt;&lt; ec.value() &lt;&lt; "]" &lt;&lt; ec.message() &lt;&lt; std::endl;} else {std::cout &lt;&lt; "Write " &lt;&lt; n &lt;&lt; " to " &lt;&lt; socket_.remote_endpoint() &lt;&lt; std::endl;}}}socket_.close();}}struct ref{explicit ref(tcp_server* p) : p_(p){}void operator()(asio::error_code ec, std::size_t n = 0){// UMU: for debug//std::cout &lt;&lt; "#" &lt;&lt; ec.value() &lt;&lt; ", " &lt;&lt; n &lt;&lt; std::endl;(*p_)(ec, n);}private:tcp_server* p_;};private:tcp::acceptor&amp; acceptor_;tcp::socket socket_;std::vector&lt;unsigned char&gt; buffer_;tcp::endpoint sender_;};#include &lt;asio/unyield.hpp&gt;int main(int argc, char* argv[]){if (argc != 5) {std::fprintf(stderr,"Usage: tcp_server &lt;port&gt; &lt;nconns&gt; ""&lt;bufsize&gt; {spin|block}\n");return 1;}unsigned short port = static_cast&lt;unsigned short&gt;(std::atoi(argv[1]));int max_connections = std::atoi(argv[2]);std::size_t buf_size = std::atoi(argv[3]);bool spin = (std::strcmp(argv[4], "spin") == 0);asio::io_service io_service(1);tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v4(), port));//std::vector&lt;boost::shared_ptr&lt;tcp_server&gt; &gt; servers;std::vector&lt;std::shared_ptr&lt;tcp_server&gt; &gt; servers;for (int i = 0; i &lt; max_connections; ++i) {//boost::shared_ptr&lt;tcp_server&gt; s(new tcp_server(acceptor, buf_size));std::shared_ptr&lt;tcp_server&gt; s(std::make_shared&lt;tcp_server&gt;(acceptor, buf_size));servers.push_back(s);(*s)(asio::error_code());}if (spin)for (;;) io_service.poll();// UMU: CPU 占用率很高elseio_service.run();} &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_830602" href="https://my.oschina.net/umu618/blog/830602">[C++ 学习笔记 6] 为什么有 std::forward？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-27 21:40:34</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>写模版的人，在遇到麻烦的时候，就会发明 std::forward 来解决他们的某种问题，他们很明白为什么需要这个东西；而初学者，看到它时，就想问，这货干嘛的？第一次看到 std::forward 时，也是一脸懵逼，看了少量示例代码（http://en.cppreference.com/w/cpp/utility/forward）后，简单推测：这个东西一般是模版内部使用的，目的是传递原始参数，从而调用正确的重载函数。扩展阅读《std::forward 完美转发》http://blog.csdn.net/tiandyoin/article/details/43604055&nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_830716" href="https://my.oschina.net/umu618/blog/830716">[C++ 学习笔记 7] Effective C++ 条款 1-4</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-01-29 17:28:25</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>第一章 让自己习惯 C++ 1、视 C++ 为一个语言联邦 &nbsp;&nbsp;&nbsp;&nbsp;C++ 是个多重范型编程语言：面向过程、面向对象、函数式、泛型、原编程式，所以他的规约很多，记住四个次语言可以帮助了解 C++：C、Object-Oriented C++、Template C++、STL。 2、尽量以 const、enum、inline 替换 #define &nbsp;&nbsp;&nbsp;&nbsp;他们的根本差别是：前三者是编译器处理的，最后者是预处理器处理的。enum 比 const 更像 #define，比如说 const 定义通常可以求地址或引用，而 enum 不行。 &nbsp;&nbsp;&nbsp;&nbsp;inline 函数比宏多了类型安全和可预料性，一个例子是讲 i++ 或 ++i 当参数传给宏时，可能导致 ++ 了多次，而传给 inline 函数则不会。 3、尽可能使用 const &nbsp;&nbsp;&nbsp;&nbsp;const 可以帮助编译器侦测错误的用法。例如，令函数返回一个常量值，往往可降低因调用者错误而造成的意外，而又不至于放弃安全性和高效性。比如当比较语句少写了一个 = 时： if (a * b = c) ... // 本意是 ==，结果导致在 a * b 的临时变量上调用 operator= &nbsp;&nbsp;&nbsp;&nbsp;如果 operator= 返回值不是 const 会导致以上错误代码编译通过！ &nbsp;&nbsp;&nbsp;&nbsp;bitwise constness 认为 const 成员函数不可以更改对象内任何 non-static 成员变量，logical constness 主张在调用者侦测不出的前提下可以修改对象内某些 bits，可以利用 mutable 释放掉 non-static 成员变量的 bitwise constness 约束。 &nbsp;&nbsp;&nbsp;&nbsp;在 const 和 non-const 成员函数中避免重复的做法是：让 non-const 成员函数调用 const 成员函数，而不要反过来。 4、确定对象被使用前已被初始化 &nbsp;&nbsp;&nbsp;&nbsp;为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。 &nbsp;&nbsp;&nbsp;&nbsp;构造函数最好使用成员初值列，而不是赋值操作，排列顺序最好和声明次序想同。 &nbsp;&nbsp;&nbsp;&nbsp;为避免跨编译单元的初始化次序问题，用 local static 对象代替 non-local static 对象，参考 Singleton 模式常见实现。 XClass&amp; GetInstance(){&nbsp;&nbsp;&nbsp;&nbsp;static XClass instance;&nbsp;&nbsp;&nbsp;&nbsp;return instance;} &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_831411" href="https://my.oschina.net/umu618/blog/831411">[C++ 学习笔记 8] Effective C++ 条款 5-12</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-02-04 00:39:58</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>第二章 构造/析构/赋值运算5、了解 C++ 默默编写并调用哪些函数&nbsp;&nbsp;&nbsp;&nbsp;编译器可以隐式为类创建：默认构造函数、复制构造函数、赋值构造函数、析构函数。6、若不想使用编译器自动产生的函数，就应该明确拒绝&nbsp;&nbsp;&nbsp;&nbsp;拒绝的方法是：把函数设为 private，只有声明没有实现。但 member 函数和 friend 函数还是可以调用 private 函数，由于没有实现，会在连接期报错，不利排插，讲错误移至编译期的方法是：private 继承 Uncopyable 类，Boost 也有个类，名为 noncopyable。7、为多态基类声明 virtual 析构函数&nbsp;&nbsp;&nbsp;&nbsp;任何类只要带有 virtual 函数，都几乎确定应该有一个 virtual 析构函数。但有 virtual 函数会降低调用效率和可优化性，所以能不用则不用，比如说，某个类没有考虑作为基类（base class）被继承，则没有必要有 virtual 析构函数，STL 的容器大多如此。8、别让异常逃离析构函数&nbsp;&nbsp;&nbsp;&nbsp;如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或者结束程序。&nbsp;&nbsp;&nbsp;&nbsp;如果客户需要对某个函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数执行该操作，而非在析构函数中。9、绝不在构造和析构过程中调用 virtual 函数&nbsp;&nbsp;&nbsp;&nbsp;因为这类调用从不降至派生类（derived class），它将调用本层的函数。10、令 operator= 返回一个 reference to *this&nbsp;&nbsp;&nbsp;&nbsp;这样才能支持连锁赋值，a = b = c = d。11、在 operator= 中处理“自我赋值”&nbsp;&nbsp;&nbsp;&nbsp;方法有：比较来源和目标对象的地址、精心周到的语句顺序、copy-and-swap。要考虑自我赋值的概率，如果很小，则比较地址的方式可能并不好，因为无视它效率更高。12、复制对象时勿忘其每一个成分&nbsp;&nbsp;&nbsp;&nbsp;复制函数应该保证复制“对象内的所有成员变量”及“所有基类成分”。当你编写一个复制函数，请确保（1）复制所有 local 成员变量，（2）调用所有基类内的适当的复制函数。&nbsp;&nbsp;&nbsp;&nbsp;不要尝试以某个复制函数实现另一个复制函数。应该将共同机能放进第三个函数中，并由两个复制函数共同调用。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_839649" href="https://my.oschina.net/umu618/blog/839649">[C++ 学习笔记 9] Effective C++ 条款 13-17</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-02-16 00:12:07</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>第三章 资源管理 13、以对象管理资源 &nbsp;&nbsp;&nbsp;&nbsp;获得资源后立刻放进对象（managing object）内。“以对象管理资源”又称“资源取得时机就是初始化时机”（Resource Acquisition Is Initialization; RAII） &nbsp;&nbsp;&nbsp;&nbsp;管理对象（managing object）运用析构函数确保资源被释放。 &nbsp;&nbsp;&nbsp;&nbsp;为防止资源泄漏，请使用 RAII 对象，它们在构造函数中获得资源并在析构函数中释放资源。 &nbsp;&nbsp;&nbsp;&nbsp;常被使用的 RAII class 是 std::shared_ptr，它是“引用计数器型智能指针”（Reference-counting smart pointer; RCSP），它无法打破环形引用（cycles of reference）。 &nbsp;&nbsp;&nbsp;&nbsp;不要用智能指针管理动态分配的数组，因为会导致错误形式的释放。参考《[C++ 学习笔记 1] delete 和 delete [] 的本质区别》，https://my.oschina.net/umu618/blog/818839。 14、在资源管理类中小心 coping 行为 &nbsp;&nbsp;&nbsp;&nbsp;复制 RAII 对象必须一并复制它管理的资源，常见的 RAII class copying 行为是： &nbsp;&nbsp;&nbsp;&nbsp;（1）禁止复制； &nbsp;&nbsp;&nbsp;&nbsp;（2）对底层资源祭出“引用计数法”（reference-count）； &nbsp;&nbsp;&nbsp;&nbsp;（3）复制底部资源； &nbsp;&nbsp;&nbsp;&nbsp;（4）转移底部资源的拥有权。 15、在资源管理类中提供对原始资源的访问 &nbsp;&nbsp;&nbsp;&nbsp;APIs 往往要求访问原始资源（raw resource），所以每一个 RAII class 应该提供一个“取得其所管理之资源”的方法，比如 .get()。 &nbsp;&nbsp;&nbsp;&nbsp;对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较方便。 16、成对使用 new 和 delete 时要采取相同形式 &nbsp;&nbsp;&nbsp;&nbsp;如果你在 new 表达式中使用 []，必须在相应的 delete 表达式中也使用 []。如果你在 new 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。参考《[C++ 学习笔记 1] delete 和 delete [] 的本质区别》，https://my.oschina.net/umu618/blog/818839。 17、以独立语句将 newed 对象置入智能指针 &nbsp;&nbsp;&nbsp;&nbsp;以独立语句将 newed 对象存储于（置入）智能指针内。如果不这么做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。 // 编译器可能为了产生更高效代码，而弹性地改变三个元语句的执行顺序// 如果 priority() 抛出异常，可能导致 new Widget 返回的指针遗失processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), priority());// 以下独立语句可行，因为编译器对“跨越语句的各项操作”没有重新排序的自由。std::shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_844930" href="https://my.oschina.net/umu618/blog/844930">[C++ 学习笔记 10] union 的顺序重要吗？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-02-23 17:15:24</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，union 顺序应该是不重要的，但在语言设计缺陷被引发时，好像有点重要了。先看 C99 怎么解决问题的： #include &lt;stdio.h&gt;struct One {    int a;};struct Two {    int a;    int b;};struct Three {    int a;    int b;    int c;};struct Test {    int type;    union {        struct One u1;        struct Two u2;        struct Three u3;    };};int main(){    // error C2078: too many initializers    //struct Test t = {2, 1, 2};    struct Test t = {.type = 2, .u2.a = 1, .u2.b = 2};    printf_s("%d, %d, %d\n", t.type, t.u2.a, t.u2.b);    return 0;} &nbsp;&nbsp;&nbsp;&nbsp;这段代码要在 VS2015 下编译，需要保存为 .c 文件，如果是默认用 .cpp 后缀，要改编译开关 Compile as C Code (/TC)。 &nbsp;&nbsp;&nbsp;&nbsp;问题在于，我们把短的结构体放在 union 最前面，导致编译器认定结构体初始化列表的元素的长度是由最短的那个结构体决定的。但我们用了 C99 的乱序初始化搞定了。然而，VS2015 的 C++ 不支持乱序初始化，以下是 C++ 版本。 #include &lt;iostream&gt;struct One {    int a;};struct Two {    int a;    int b;};struct Three {    int a;    int b;    int c;};struct Test {    int type;    union {        One u1;        Two u2;        Three u3;    };};int main(){    struct Test t = {1, 1};    // error C2078: too many initializers    //struct Test t = {2, 1, 2};    //struct Test t = {3, 1, 2, 3};    std::cout &lt;&lt; t.type &lt;&lt; ", " &lt;&lt; t.u2.a &lt;&lt; std::endl;    return 0;} &nbsp;&nbsp;&nbsp;&nbsp;把 union 顺序换一下，把 Three 放在最前，可以解决……如果您知道不改顺序的更好的方法，请不吝告知，仅限 VS2015，POD，不要用 class 构造函数的思路。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_848725" href="https://my.oschina.net/umu618/blog/848725">跟 UMU 一起玩 OpenWRT（入门篇12）：代理上 QQ</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-03-01 15:57:03</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;在之前的文章《跟 UMU 一起玩 OpenWRT（入门篇10）：穿透内网》，https://my.oschina.net/umu618/blog/295193，介绍了从家里连到公司内网，现在需求反过来了，想在公司代理到家里，让公司的 QQ 使用家里的网络出口。 &nbsp;&nbsp;&nbsp;&nbsp;还是那些熟悉的工具！首先，家里的路由器要刷好 OpenWRT，绑定一个动态域名，记为 HomeRouter。 &nbsp;&nbsp;&nbsp;&nbsp;在 Windows 下用 putty 连到 HomeRouter，基本就成功了~开 tunnels 方法如图：  &nbsp;&nbsp;&nbsp;&nbsp;或者用 ： PLINK.EXE -N -D 1080 root@HomeRouter &nbsp;&nbsp;&nbsp;&nbsp;最后是 QQ 的设置：</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_849345" href="https://my.oschina.net/umu618/blog/849345">跟 UMU 一起玩 OpenWRT（入门篇13）：改进 autossh 支持多实例</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-03-02 11:46:52</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;在之前的文章《跟 UMU 一起玩 OpenWRT（入门篇10）：穿透内网》，https://my.oschina.net/umu618/blog/295193，介绍了 autossh 的使用，现在多了一个需求：想在内网打通多条隧道，即让 autossh 能运行多个 ssh 实例。 &nbsp;&nbsp;&nbsp;&nbsp;首先在 /etc/config/autossh 里增加一个 section，看起来如下： config autossh        option gatetime '0'        option monitorport '0'        option poll '600'        option ssh '-i /etc/dropbear/id_rsa -N -T -R 2222:localhost:22 root@Server1'config autossh        option gatetime '0'        option monitorport '0'        option poll '600'        option ssh '-i /etc/dropbear/id_rsa -N -T -R 2222:localhost:22 root@Server2' &nbsp;&nbsp;&nbsp;&nbsp;然后改进一下 /etc/init.d/autossh，让它支持多实例，给 start_instance() 函数增加两行： export SERVICE_MATCH_NAME=1export SERVICE_NAME="$section" &nbsp;&nbsp;&nbsp;&nbsp;最终 start_instance() 函数看起来是这样： start_instance() {local section="$1"config_get ssh "$section" 'ssh'config_get gatetime "$section" 'gatetime'config_get monitorport "$section" 'monitorport'config_get poll "$section" 'poll'export AUTOSSH_GATETIME="${gatetime:-30}"export AUTOSSH_POLL="${poll:-600}"export SERVICE_MATCH_NAME=1export SERVICE_NAME="$section"#export SERVICE_DEBUG=1service_start /usr/sbin/autossh -M ${monitorport:-20000} -f ${ssh}} &nbsp;&nbsp;&nbsp;&nbsp;注意：这样改是有副作用的，您反复启动多次就知道了……启动的命令是： /etc/init.d/autossh start &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_850196" href="https://my.oschina.net/umu618/blog/850196">[C++ 学习笔记 11] Effective C++ 条款 18-25</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-03-03 11:18:44</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>第四章 设计与声明 18、让接口容易被正确使用，不易被误用 &nbsp;&nbsp;&nbsp;&nbsp;“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。一致性的例子：STL 容器都有 size 成员函数。不一致性对开发人员造成的心理负担，没有任何一个 IDE 可以完全抹除。 &nbsp;&nbsp;&nbsp;&nbsp;“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 &nbsp;&nbsp;&nbsp;&nbsp;std::shared_ptr 使用每个指针专属的删除器，消除“cross-DLL problem”；它还支持定制删除器，可被用来自动解除互斥锁（mutexes，见条款 14，https://my.oschina.net/umu618/blog/839649）。 19、设计 class 犹如设计 type &nbsp;&nbsp;&nbsp;&nbsp;Class 设计就是 type 的设计，在定义一个新 type 之前，要考虑以下主题： （1）新 type 的对象应该如何被创建和销毁？ （2）对象的初始化和赋值该有什么差别？ （3）新 type 的对象如果被以值传递（pass by value），意味着什么？ （4）什么的新 type 的合法值？setter 函数要检查错误。 （5）新 type 需要配合某个继承图系（inheritance graph）吗？这影响函数——尤其是析构函数，是否为 virtual（见条款 7，https://my.oschina.net/umu618/blog/831411）。 （6）新 type 需要什么样的转换？如果希望 T1 被隐式转换为 T2，必须在 class T1 内写一个类型转换函数（operator T2）或在 class T2 内写一个可被单一实参调用（non-explicit-one-argument）的构造函数。如果只允许 explicit 构造函数存在，就得写出专门负责转换的函数，且不得为类型转换操作符（type conversion perators）或 non-explicit-one-argument 构造函数。（条款 15 有隐式和显式转换函数的范例，https://my.oschina.net/umu618/blog/839649） （7）什么样的操作符和函数对此新 type 而言是合理的？这决定你的 class 有哪些函数，其中哪些是 member 函数，哪些则否。（参考条款 23, 24, 26） （8）什么样的标准函数应该驳回？声明为 private。（见条款 6，https://my.oschina.net/umu618/blog/831411） （9）谁该取用新 type 的成员？这个问题帮你决定成员的可见性（public、protected、private）。也帮你决定哪个 classes 和/或 functions 应该是 friends，以及将它们嵌套于另一个之内是否合理。 （10）什么是新 type 的未声明接口（undeclared interface）？它对效率、异常安全性（见条款 29）以及资源运用（例如多任务锁定和动态内存）提供何种保证？你在这些方面提供的保证，将为你的 class 实现代码加上相应的约束条件。 （11）新 type 有多么一般化？new class or new class template? （12）真的需要一个新 type 吗？如果只是定义新的子类（derived class）以便为既有 class 添加机能，那么也许单纯定义一或多个 non-member 函数或 20、宁以 pass-by-reference-to-const 替换 pass-by-value &nbsp;&nbsp;&nbsp;&nbsp;尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem，即派生类被转化成基类时丢失派生类特有的成分）。 &nbsp;&nbsp;&nbsp;&nbsp;以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。 21、必须返回对象时，别妄想返回其 reference &nbsp;&nbsp;&nbsp;&nbsp;不要返回 pointer 或 reference 指向一个 local stack 对象，因为离开作用域即被销毁。 &nbsp;&nbsp;&nbsp;&nbsp;不要返回 reference 指向一个 heap-allocated 对象，因为无法保证配套 delete。 &nbsp;&nbsp;&nbsp;&nbsp;不要返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。 #include &lt;stdio.h&gt;#define _WINSOCK_DEPRECATED_NO_WARNINGS // to use inet_ntoa#include &lt;winsock2.h&gt;#pragma comment(lib, "ws2_32.lib")int main(){    in_addr a1 = {1, 2, 3, 4};    in_addr a2 = {5, 6, 7, 8};    printf_s("You think it's: %s, ", inet_ntoa(a1));    printf_s("%s\n", inet_ntoa(a2));    printf_s("But in fact it's: %s, %s\n", inet_ntoa(a1), inet_ntoa(a2));    return 0;} &nbsp;&nbsp;&nbsp;&nbsp;以上代码输出为：   You think it's: 1.2.3.4, 5.6.7.8 But in fact it's: 1.2.3.4, 1.2.3.4  22、将成员变量声明为 private &nbsp;&nbsp;&nbsp;&nbsp;切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性。 &nbsp;&nbsp;&nbsp;&nbsp;protected 并不比 public 更具封装型。 23、宁以 non-member、non-friend 替换 member 函数 &nbsp;&nbsp;&nbsp;&nbsp;宁可拿 non-member non-friend 函数替换 member 函数。这样做可以增加封装型、包裹弹性（packaging flexibility）和技能扩充性。 24、若所有参数皆需类型转换，请为此采用 non-member 函数 &nbsp;&nbsp;&nbsp;&nbsp;member 函数的反面是 non-member 函数，而不是 friend 函数。 &nbsp;&nbsp;&nbsp;&nbsp;设计 operator * 时，要能支持乘法交换律。 &nbsp;&nbsp;&nbsp;&nbsp;如果你需要为某个函数的所有参数（包括 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个 non-member。从 Object-Oriented C++ 跨进 Template C++ 时，会有新争议和解法，参考条款 46。 25、考虑写出一个不抛异常的 swap 函数 &nbsp;&nbsp;&nbsp;&nbsp;通常我们不能改变 std 命名空间内的任何东西，但可以为 temlates 制造特化版本。 &nbsp;&nbsp;&nbsp;&nbsp;C++ 只允许对 class templates 偏特化（partially specialize），而对 function templates 则不许。 &nbsp;&nbsp;&nbsp;&nbsp;当 std::swap 对你的类型效率不高时，提供一个 swap 成员函数，并确定这个函数不抛出异常。因为成员 swap 的一个最好应用是帮助 classes 和 class templates 提供强烈的异常安全性（exception-safety）保障。条款 29 细说。 &nbsp;&nbsp;&nbsp;&nbsp;如果你提供了一个 member swap，也该提供一个 non-member swap 用来条用前者。对于 classes（而非 templates），也请特化 std::swap。 &nbsp;&nbsp;&nbsp;&nbsp;调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并不带任何“命名空间资格修饰”。 &nbsp;&nbsp;&nbsp;&nbsp;为“用户定义类型”进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std er</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_864903" href="https://my.oschina.net/umu618/blog/864903">[C++ 学习笔记 12] Effective C++ 条款 26-31</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-03-22 17:24:24</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>第五章 实现26、尽可能延后变量定义式的出现时间&nbsp;&nbsp;&nbsp;&nbsp;太早出现，可能因为下面出现异常，导致构造白白浪费。&nbsp;&nbsp;&nbsp;&nbsp;延后可以增加程序的清晰度、改善效率。27、尽量少做转型动作&nbsp;&nbsp;&nbsp;&nbsp;dynamic_casts 有性能代价，应该尽量避免。绝对要避免“连串动态转型”（cascading dynamic casts）。&nbsp;&nbsp;&nbsp;&nbsp;如果转型是必要的，试着将它隐藏于某个函数。客户可以条用该函数，而不需要讲转型放进他们的代码内。&nbsp;&nbsp;&nbsp;&nbsp;宁可使用 C++-style 转型，不要使用旧式转型。前者很容易辨识出来，而且有分门别类的职掌。28、避免返回 handles 指向对象内部成分&nbsp;&nbsp;&nbsp;&nbsp;避免返回 handles（包括 reference、指针、迭代器）指向对象内部，可以增加封装型，帮助 const 成员函数的行为像个 const，将发生“虚吊号码牌”（dangling handles）的可能性降至最低。&nbsp;&nbsp;&nbsp;&nbsp;反之，传出去的 handles 可能让你暴露在“handles ”的风险下。29、为“异常安全”而努力是值得的&nbsp;&nbsp;&nbsp;&nbsp;当异常被抛出时，异常安全的函数会：（1）不泄漏任何资源；（2）不允许数据败坏。&nbsp;&nbsp;&nbsp;&nbsp;异常安全函数（Exception-safe functions）提供这三个保证之一：（1）基本承诺，如果异常抛出，程序内的任何事物仍然保持在有效状态下。（2）强烈保证，如果异常抛出，程序状态不改变。（3）不抛掷（nothrow）保证，承诺绝不抛出异常。&nbsp;&nbsp;&nbsp;&nbsp;“强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可以实现或具备现实意义。&nbsp;&nbsp;&nbsp;&nbsp;木桶原理：函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。30、透彻了解 inlining 的里里外外&nbsp;&nbsp;&nbsp;&nbsp;将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。&nbsp;&nbsp;&nbsp;&nbsp;不要只因为 function templates 出现在头文件，就将它们声明为 inline。&nbsp;&nbsp;&nbsp;&nbsp;所有对 virtual 函数的调用（除非是最平淡无奇的）都会使 inlining 落空。&nbsp;&nbsp;&nbsp;&nbsp;编译器通常不对“通过函数指针而进行的调用”实施 inlining，这意味着对 inline 函数的调用最终是否 inlined 由编译器决定。&nbsp;&nbsp;&nbsp;&nbsp;构造函数和析构函数往往是 inlining 的糟糕候选，因为他们隐含一些由编译器产生的代码。&nbsp;&nbsp;&nbsp;&nbsp;inline 函数的风险：它们无法随着程序库的升级而升级，必须重新编译。31、将文件间的编译依存关系降至最低&nbsp;&nbsp;&nbsp;&nbsp;支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。&nbsp;&nbsp;&nbsp;&nbsp;程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法适用于 templates。（1）如果使用 object references 或 object pointers 可以完成任务，就不要使用 object。（2）如果可以，尽量以 class 声明式替换 class 定义式。（3）为声明式和定义式提供不同的头文件。&nbsp;&nbsp;&nbsp;&nbsp;Java 和 .NET 都不允许在 Interfaces 内实现成员变量或成员函数，但 C++ 可以。&nbsp;&nbsp;&nbsp;&nbsp;Handle classes 和 Interface classes 有微小的性能损失，但为了降低 classes 之间的耦合性是值得的。如果性能比耦合性重要，才用具象类（concrete ）替换它们。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_866469" href="https://my.oschina.net/umu618/blog/866469">C++ 11 特征之删除默认成员函数</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-03-24 18:14:34</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;任务：类实例不让复制（noncopyable）。 &nbsp;&nbsp;&nbsp;&nbsp;“不写复制构造函数”是不行的，因为 C++ 会默认给你生成一个。C++ 03 为了实现&nbsp;noncopyable 需要把复制构造函数和复制函数设为 private： private:      noncopyable( const noncopyable&amp; );      noncopyable&amp; operator=( const noncopyable&amp; ); &nbsp;&nbsp;&nbsp;&nbsp;使用上也很简单，从 noncopyable 类派生就好（上面的代码不全，所以用 boost 的）： class YourClass : private boost::noncopyable{} &nbsp;&nbsp;&nbsp;&nbsp;这个方法对处女座还是有一定杀伤力的，没用的东西为什么不直接删掉呢？所以 C++ 11 就允许你这么干了！ YourClass(const YourClass&amp;) = delete;YourClass&amp; operator=(const YourClass&amp;) = delete; &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_867419" href="https://my.oschina.net/umu618/blog/867419">完全免费的 Windows Server 系统，不需要序列号、不需要激活、更不需要破解</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-03-25 23:34:47</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp;&nbsp;&nbsp;2009-04-17 22:06 在百度空间上发表过一次，后来百度空间倒闭了……最近给自己家里搭建家庭文件共享服务器用到，所以在这边再发一次。&nbsp;&nbsp;&nbsp;&nbsp;2009 年时，由于项目需要，用过 Hyper-V Server 2008。到了 2012-09-25&nbsp;升级为 Hyper-V&nbsp;Server&nbsp;2012。这次（2017-03-22）用的是 Hyper-V Server 2016。这么多年一直还是完全免费的。&nbsp;&nbsp;&nbsp;&nbsp;Hyper-V&nbsp;Server 是基于&nbsp;Windows&nbsp;Server&nbsp;Server&nbsp;Core&nbsp;x64&nbsp;的虚拟机服务器系统，要正常提供虚拟机服务，&nbsp;CPU&nbsp;必须满足三个条件：x64、DEP&nbsp;(Data&nbsp;Execution&nbsp;Prevention)、HV&nbsp;(Hardware&nbsp;Virtualization)，但 UMU 不需要它的专业本领——虚拟机服务，所以只需要有&nbsp;x64&nbsp;CPU&nbsp;就可以了。目前只使用他的副业，作为网上邻居（SMB）服务器和静态文件 HTTP Server，就家用而言，绝对够用，前者是系统自带的共享功能，用 net share 命令开启，后者安装 node.js + http-server 模块。&nbsp;&nbsp;&nbsp;&nbsp;但它不是完整的 Windows Server，比如您想跑&nbsp;IIS，那就不能使用它了。它最适合的情况是您开发了一些系统服务（NT&nbsp;Service）类的应用，比如游戏服务端、聊天软件服务端，想发布到&nbsp;Windows&nbsp;Server&nbsp;上。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_916415" href="https://my.oschina.net/umu618/blog/916415">解决对话框字体模糊</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-06-07 16:08:57</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>现象： 1、在 VS 的资源编辑器里，点预览对话框，即：Test Dialog(Ctrl+T)，字体十分平滑，无锯齿。 2、实际运行 exe 时，却发现对话框上的文字模糊了，字体出现锯齿。 &nbsp; 解决过程： 1、怀疑是 DPI 导致，怀疑是程序没有明确声明自己支持高 DPI。 2、用资源编辑器查看了 manifest，和记事本、资源管理器等系统自带应用对比，发现确实有个不一样的： &lt;dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings"&gt;PerMonitorV2&lt;/dpiAwareness&gt; 3、尝试改工程属性 - Manifest Tool - Input and Output - DPI Awareness 为&nbsp;Per Monitor High DPI Aware，问题解决。 &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1094080" href="https://my.oschina.net/umu618/blog/1094080">Opus 编解码遇到的怪事</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-01 17:23:52</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>&nbsp; &nbsp; 最近参考 ffmpeg 的 transcoding_aac 示例代码，写了一个&nbsp;transcoding_opus，并拿 MP3 测试转码，结果发现转完的 opus 文件的 SampleFormat 和指定的并不一样。UMU 的代码是把源文件解码出来的 sample 先 resample 成&nbsp;AV_SAMPLE_FMT_S16 格式，然后再交给 opus encoder 去编码的，但是编完用 ffprobe 查看，发现&nbsp;SampleFormat 变成&nbsp;AV_SAMPLE_FMT_FLTP。 &nbsp; &nbsp; 那么第一个问题来了，为什么会这样？ &nbsp; &nbsp; 开始研究，首先 UMU 把 opus encoder 支持的 sample_fmt 打印出来，发现只有两种：AV_SAMPLE_FMT_S16、AV_SAMPLE_FMT_FLT，压根就没有&nbsp;AV_SAMPLE_FMT_FLTP，强行指定&nbsp;AV_SAMPLE_FMT_FLTP 之后，直接报错，不支持这种&nbsp;sample_fmt。 &nbsp; &nbsp; 推测，真的被编码为&nbsp;AV_SAMPLE_FMT_S16 了，是 ffprobe 的问题，于是自己写了个简化版的 ffprobe，流程几乎是一样的，出来的结果——果然一模一样……打印出&nbsp;AV_SAMPLE_FMT_FLTP。 &nbsp; &nbsp; 接着怀疑 ffprobe 用的 decoder，于是去看了&nbsp;avcodec_find_decoder 返回的&nbsp;AVCodec，打印一下 name 和 long_name，和&nbsp;transcoding_opus 的&nbsp;avcodec_find_encoder 返回的一比，果然不一样…… &nbsp; &nbsp; 选用的编码器是这样的： AVCodec ff_libopus_encoder = {    .name            = "libopus",    .long_name       = NULL_IF_CONFIG_SMALL("libopus Opus"),    .type            = AVMEDIA_TYPE_AUDIO,    .id              = AV_CODEC_ID_OPUS,    .priv_data_size  = sizeof(LibopusEncContext),    .init            = libopus_encode_init,    .encode2         = libopus_encode,    .close           = libopus_encode_close,    .capabilities    = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SMALL_LAST_FRAME,    .sample_fmts     = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,                                                      AV_SAMPLE_FMT_FLT,                                                      AV_SAMPLE_FMT_NONE },    .supported_samplerates = libopus_sample_rates,    .priv_class      = &amp;libopus_class,    .defaults        = libopus_defaults,}; &nbsp; &nbsp; 而选用的解码器是这样的： AVCodec ff_opus_encoder = {    .name           = "opus",    .long_name      = NULL_IF_CONFIG_SMALL("Opus"),    .type           = AVMEDIA_TYPE_AUDIO,    .id             = AV_CODEC_ID_OPUS,    .defaults       = opusenc_defaults,    .priv_class     = &amp;opusenc_class,    .priv_data_size = sizeof(OpusEncContext),    .init           = opus_encode_init,    .encode2        = opus_encode_frame,    .close          = opus_encode_end,    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,    .capabilities   = AV_CODEC_CAP_EXPERIMENTAL | AV_CODEC_CAP_SMALL_LAST_FRAME | AV_CODEC_CAP_DELAY,    .supported_samplerates = (const int []){ 48000, 0 },    .channel_layouts = (const uint64_t []){ AV_CH_LAYOUT_MONO,                                            AV_CH_LAYOUT_STEREO, 0 },    .sample_fmts    = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP,                                                     AV_SAMPLE_FMT_NONE },}; &nbsp; &nbsp; 问题清楚了，看来用 ID 查找编解码器并不靠谱，因为这个 ID 是 Type ID，不是 Item ID，还是改为用 name 来找： //AVCodec *output_codec = avcodec_find_encoder(AV_CODEC_ID_OPUS);AVCodec *output_codec = avcodec_find_encoder_by_name("opus"); &nbsp; &nbsp; 那么，第二个问题顺势而来……哪个比较牛？ &nbsp; &nbsp; 用 AV_SAMPLE_FMT_FLTP 后 frame_size 是 120，用其它是 960，frame_size 小有小的好处，比如在做实时编码直播时，理论延迟会更小。 &nbsp;&nbsp;&nbsp;&nbsp;经过测试，用 AV_SAMPLE_FMT_FLTP 的 opus 比 libopus 压缩率普遍略高一些，但它只支持 48000Hz 一种 sample_rate，libopus 支持的更多：48000, 24000, 16000, 12000, 8000。</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1153916" href="https://my.oschina.net/umu618/blog/1153916">解决 Windows 10 无法使用 IrDA</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-04 10:10:11</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>&nbsp; &nbsp; 最近买了一个 Intel NUC，有个红外线端口，昨晚想尝试用 WinSock 对它编程，结果发现到 bind 就失败了，错误码是 10050，套接字操作遇到了一个已死的网络。 &nbsp; &nbsp; 搜了一把，发现是 Windows 10 移除了 IrDA 的协议栈，但是还可以装回来，参考：https://support.microsoft.com/en-us/help/3150989/an-irda-networking-device-does-not-work-in-windows-10-version-1511，三条命令： netcfg -u ms_irda netcfg -c p -I ms_irdasc start irdasc start irmon &nbsp;&nbsp;&nbsp;&nbsp;IrDA 要死了，不推荐这么操作！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1154562" href="https://my.oschina.net/umu618/blog/1154562">Windows 的 WAVEFORMATEX 转 ffmpeg 的 AVSampleFormat 类型</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-04 20:46:31</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>任务：用 Windows 的&nbsp;IAudioCaptureClient 对象采集音频，然后用 ffmpeg 编码。 问题：一些类型定义不一样，比如&nbsp;SampleFormat。 inline AVSampleFormat GetSampleFormat(const WAVEFORMATEX *wave_format){    switch (wave_format-&gt;wFormatTag) {    case WAVE_FORMAT_PCM:        if (16 == wave_format-&gt;wBitsPerSample) {            return AV_SAMPLE_FMT_S16;        }        if (32 == wave_format-&gt;wBitsPerSample) {            return AV_SAMPLE_FMT_S32;        }        break;    case WAVE_FORMAT_IEEE_FLOAT:        return AV_SAMPLE_FMT_FLT;    case WAVE_FORMAT_ALAW:    case WAVE_FORMAT_MULAW:        return AV_SAMPLE_FMT_U8;    case WAVE_FORMAT_EXTENSIBLE:    {        const WAVEFORMATEXTENSIBLE *wfe = reinterpret_cast&lt;const WAVEFORMATEXTENSIBLE *&gt;(wave_format);        if (KSDATAFORMAT_SUBTYPE_IEEE_FLOAT == wfe-&gt;SubFormat) {            return AV_SAMPLE_FMT_FLT;        }        if (KSDATAFORMAT_SUBTYPE_PCM == wfe-&gt;SubFormat) {            if (16 == wave_format-&gt;wBitsPerSample) {                return AV_SAMPLE_FMT_S16;            }            if (32 == wave_format-&gt;wBitsPerSample) {                return AV_SAMPLE_FMT_S32;            }        }        break;    }    default:        break;    }    return AV_SAMPLE_FMT_NONE;} &nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1189289" href="https://my.oschina.net/umu618/blog/1189289">UEFI 里的 IGD Minimum Memory 和 IGD Aperture Size</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-06 23:48:26</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>&nbsp;&nbsp; 今天进 UEFI 看到集显的两个设置选项：IGD Minimum Memory 和 IGD Aperture Size，想着 UMU 的 NUC 有 32G 内存，要不要改大点？然后搜一下他们的作用，结果发现最好不要改……&nbsp;&nbsp;&nbsp;&nbsp;参考文章：https://communities.intel.com/thread/106880https://communities.intel.com/thread/106428&nbsp;</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1335051" href="https://my.oschina.net/umu618/blog/1335051">[C++ 学习笔记 13] Effective C++ 条款 32-40</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-11 16:19:37</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'># [C++ 学习笔记 13] Effective C++ 条款 32-40## 第六章 继承与面向对象设计### 32、确定你的 public 继承塑模出 is-a 关系“public 继承”意味 is-a。适用于 base classes 身上的每一件事一定也适用于 derived classes 身上，因为每一个 derived classes 对象也都是一个 base class 对象。classes 之间的关系除了 is-a 之外，还有 has-a（有一个）和 is-implemented-in-terms-of（根据某物实现出）两种常见的关系。### 33、避免遮掩继承而来的名称derived classes 内的名称会掩盖 base classes 内的名称。在 public 继承下从来没有人希望如此。为了让被掩盖的名称再见天日，可使用 using 声明式或转交函数（forwarding function）。### 34、区分接口继承和实现继承接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。成员函数的接口总是会被继承。pure virtual 函数有两个最突出的特征：他们必须被任何“继承了它们”的具象 class 重新声明，而且它们在抽象 class 中通常没有定义。声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数接口。声明简朴的（非纯）impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现。声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现。### 35、考虑 virtual 函数以外的其它选择#### 藉由 Non-Virtual 手法实现 Template Method 模式```class GameCharacter {public:    int HealthValue() const           // derived classes 不重新定义它    {        ...        int value = DoHealthValue();        ...        return value;    }    ...private:    // 不是必须 private    virtual int DoHealthValue() const // derived classes 可重新定义它    {        ...                           // 缺省算法    }};```令客户通过 public non-virtual 成员函数间接调用 private virtual 函数，称之为 non-virtual interface（NVI）手法。它是 Template Method 设计模式的一个独特表现形式。non-virtual 函数称为 virtual 函数的外覆器（wrapper）。#### 藉由 Function Pointers 手法实现 Strategy 模式缺点：将机能从成员函数移到 class 外部函数，导致非成员函数无法访问 class 的 non-public 成员。#### 藉由 std::function 手法实现 Strategy 模式#### 古典的 Strategy 模式古典的 Strategy 模式会将健康函数做成一个分离的继承体系中的 virtual 成员函数。### 36、绝不重新定义继承而来的 non-virtual 函数class 内声明一个 non-virtual 函数会为该 class 建立起一份不变性（invariant），凌驾其特异性（specialization）。### 37、绝不重新定义继承而来的缺省参数值本条款的讨论局限于“继承一个带有缺省参数值的 virtual 函数”，绝对不要新定义继承而来的缺省参数值，因为缺省参数都是静态绑定，而 virtual 函数——你唯一应该复写的东西——却是动态绑定。### 38、通过复合塑模出 has-a 或“根据某物实现出”复合（composition）的意义和 public 继承完全不同。在应用域（application domain），复合意味 has-a（有一个）。在实现域（implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）。### 39、明智而审慎地使用 private 继承Private 继承意味 is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。和复合（composition）不同，private 继承可以造成 empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。### 40、明智而审慎地使用多重继承多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。virtual 继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。多重继承的确有正当用途。其中一个情节涉及“public 继承某个 Interface class”和“private 继承某个协助实现的 class”的两相组合。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1476439" href="https://my.oschina.net/umu618/blog/1476439">Windows 的 ChannelMask 转 ffmpeg 的 ChannelLayout</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-20 16:02:47</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>最近写录音程序，发现 MBP 的扬声器是 4 频道的，然后在抓音频保存时，Opus 编码器居然不支持 4 个频道，avcodec_open2() 会返回错误码 -22，Invalid argument。解决方法就是 resample 成 AV_CH_LAYOUT_STEREO。搞定后就顺便细研了这个 ChannelLayout，UMU 的代码里需要把微软 CoreAudio 的一些参数转成 ffmpeg 的，比如之前写的《[Windows 的 WAVEFORMATEX 转 ffmpeg 的 AVSampleFormat 类型](https://my.oschina.net/umu618/blog/1154562)》，这次写 ChannelLayout 的转换。ffmpeg 的 channel layouts 定义：```/** * @} * @defgroup channel_mask_c Audio channel layouts * @{ * */#define AV_CH_LAYOUT_MONO              (AV_CH_FRONT_CENTER)#define AV_CH_LAYOUT_STEREO            (AV_CH_FRONT_LEFT|AV_CH_FRONT_RIGHT)#define AV_CH_LAYOUT_2POINT1           (AV_CH_LAYOUT_STEREO|AV_CH_LOW_FREQUENCY)#define AV_CH_LAYOUT_2_1               (AV_CH_LAYOUT_STEREO|AV_CH_BACK_CENTER)#define AV_CH_LAYOUT_SURROUND          (AV_CH_LAYOUT_STEREO|AV_CH_FRONT_CENTER)#define AV_CH_LAYOUT_3POINT1           (AV_CH_LAYOUT_SURROUND|AV_CH_LOW_FREQUENCY)#define AV_CH_LAYOUT_4POINT0           (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_CENTER)#define AV_CH_LAYOUT_4POINT1           (AV_CH_LAYOUT_4POINT0|AV_CH_LOW_FREQUENCY)#define AV_CH_LAYOUT_2_2               (AV_CH_LAYOUT_STEREO|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)#define AV_CH_LAYOUT_QUAD              (AV_CH_LAYOUT_STEREO|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)#define AV_CH_LAYOUT_5POINT0           (AV_CH_LAYOUT_SURROUND|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)#define AV_CH_LAYOUT_5POINT1           (AV_CH_LAYOUT_5POINT0|AV_CH_LOW_FREQUENCY)#define AV_CH_LAYOUT_5POINT0_BACK      (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)#define AV_CH_LAYOUT_5POINT1_BACK      (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_LOW_FREQUENCY)#define AV_CH_LAYOUT_6POINT0           (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_CENTER)#define AV_CH_LAYOUT_6POINT0_FRONT     (AV_CH_LAYOUT_2_2|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)#define AV_CH_LAYOUT_HEXAGONAL         (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_BACK_CENTER)#define AV_CH_LAYOUT_6POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_CENTER)#define AV_CH_LAYOUT_6POINT1_BACK      (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_BACK_CENTER)#define AV_CH_LAYOUT_6POINT1_FRONT     (AV_CH_LAYOUT_6POINT0_FRONT|AV_CH_LOW_FREQUENCY)#define AV_CH_LAYOUT_7POINT0           (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)#define AV_CH_LAYOUT_7POINT0_FRONT     (AV_CH_LAYOUT_5POINT0|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)#define AV_CH_LAYOUT_7POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)#define AV_CH_LAYOUT_7POINT1_WIDE      (AV_CH_LAYOUT_5POINT1|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)#define AV_CH_LAYOUT_7POINT1_WIDE_BACK (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)#define AV_CH_LAYOUT_OCTAGONAL         (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_CENTER|AV_CH_BACK_RIGHT)#define AV_CH_LAYOUT_HEXADECAGONAL     (AV_CH_LAYOUT_OCTAGONAL|AV_CH_WIDE_LEFT|AV_CH_WIDE_RIGHT|AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_RIGHT|AV_CH_TOP_BACK_CENTER|AV_CH_TOP_FRONT_CENTER|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT)#define AV_CH_LAYOUT_STEREO_DOWNMIX    (AV_CH_STEREO_LEFT|AV_CH_STEREO_RIGHT)```ffmpeg 的频道位置信息：```#define AV_CH_FRONT_LEFT             0x00000001#define AV_CH_FRONT_RIGHT            0x00000002#define AV_CH_FRONT_CENTER           0x00000004#define AV_CH_LOW_FREQUENCY          0x00000008#define AV_CH_BACK_LEFT              0x00000010#define AV_CH_BACK_RIGHT             0x00000020#define AV_CH_FRONT_LEFT_OF_CENTER   0x00000040#define AV_CH_FRONT_RIGHT_OF_CENTER  0x00000080#define AV_CH_BACK_CENTER            0x00000100#define AV_CH_SIDE_LEFT              0x00000200#define AV_CH_SIDE_RIGHT             0x00000400#define AV_CH_TOP_CENTER             0x00000800#define AV_CH_TOP_FRONT_LEFT         0x00001000#define AV_CH_TOP_FRONT_CENTER       0x00002000#define AV_CH_TOP_FRONT_RIGHT        0x00004000#define AV_CH_TOP_BACK_LEFT          0x00008000#define AV_CH_TOP_BACK_CENTER        0x00010000#define AV_CH_TOP_BACK_RIGHT         0x00020000#define AV_CH_STEREO_LEFT            0x20000000  ///wFormatTag) {        return reinterpret_cast(wave_format)->dwChannelMask;    }    return av_get_default_channel_layout(wave_format->nChannels);}```</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1476510" href="https://my.oschina.net/umu618/blog/1476510">把 ffmpeg AVAudioFifo/AVFrame 数据读到共享内存</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-20 16:45:38</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>一般情况下操作 AVAudioFifo/AVFrame 都是用全套 ffmpeg API，内部自己管理内存，不需要了解它们内部怎么组织内存。比如：```inline int InitFrame(AVFrame *&frame, int frame_size = kTargetSamplesPerFrame){    frame = av_frame_alloc();    if (nullptr == frame) {        return AVERROR(ENOMEM);    }    frame->nb_samples = frame_size;    frame->channel_layout = av_get_default_channel_layout(kTargetChannels);    frame->format = kTargetSampleFormat;    frame->sample_rate = kTargetSampleRate;    int error = av_frame_get_buffer(frame, 0);    if (error data, kTargetSamplesPerFrame);    ...}```这里读了一个 AVFrame 出来，并不需要知道具体的内存布局，但如果要写入 FileMapping 对象里，就得知道了！参考以下函数：```int av_audio_fifo_read(AVAudioFifo *af, void **data, int nb_samples){    int i, size;    if (nb_samples nb_samples);    if (!nb_samples)        return 0;    size = nb_samples * af->sample_size;    for (i = 0; i nb_buffers; i++) {        if (av_fifo_generic_read(af->buf[i], data[i], size, NULL) nb_samples -= nb_samples;    return nb_samples;}```和 AVFrame 定义：```typedef struct AVFrame {#define AV_NUM_DATA_POINTERS 8    /**     * pointer to the picture/channel planes.     * This might be different from the first allocated byte     *     * Some decoders access areas outside 0,0 - width,height, please     * see avcodec_align_dimensions2(). Some filters and swscale can read     * up to 16 bytes beyond the planes, if these filters are to be used,     * then 16 extra bytes must be allocated.     *     * NOTE: Except for hwaccel formats, pointers not needed by the format     * MUST be set to NULL.     */    uint8_t *data[AV_NUM_DATA_POINTERS];    /**     * For video, size in bytes of each picture line.     * For audio, size in bytes of each plane.     *     * For audio, only linesize[0] may be set. For planar audio, each channel     * plane must be the same size.     *     * For video the linesizes should be multiples of the CPUs alignment     * preference, this is 16 or 32 for modern desktop CPUs.     * Some code requires such alignment other code can be slower without     * correct alignment, for yet other it makes no difference.     *     * @note The linesize may be larger than the size of usable data -- there     * may be extra padding present for performance reasons.     */    int linesize[AV_NUM_DATA_POINTERS];...};```以 AV_SAMPLE_FMT_S16 为例，发现 InitFrame() 里的 av_frame_get_buffer() 之后只有 linesize[0] 是非 0，即 data[0] 的分配长度，其它 7 个都是 0，即 data[1] -> data[7] 都没有分配，于是猜测就是读 data[0]，长度 linesize[0]，尝试把它写到 FileMapping 里，果然是对的。如果 SampleFormat 是带 P 的，就不是只有 data[0] 了，有几个 channel 就有几个 data，要相应改变。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1476567" href="https://my.oschina.net/umu618/blog/1476567">各种录音</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-07-20 17:42:29</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>挖掘奇葩需求，把录音做到极致。## 从外设录音最典型的就是麦克风，内置麦克风、外置麦克风，其实还有一种通过 LineIn 插入的其它播放器设备，比如 CD、DVD 等。采集这种音频的方法可以只用 ffmpeg 搞定：av_find_input_format("dshow")...，也可以用 CoreAudio 搞定：```enumerator->EnumAudioEndpoints(eCapture, DEVICE_STATE_ACTIVE, ...audio_client->Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_EVENTCALLBACK ...```## 从播放设备回放录音采集方式是用 CoreAudio：```enumerator->(eRender, DEVICE_STATE_ACTIVE, ...audio_client->Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, ...```这种方式会混音，比如说您开个 foobar 播歌，再开个 QQ 影音看电影，则会录到这两个应用程序的混音，嗯，如果 QQ 再嘀嘀嘀，也是会混进去的……## 只录制某个应用程序的音比前一种更先进一些，多个播放器同时播歌，我们可以只录其中一个。当然这个技术还有其它用途……采集方法是：Hook CoreAudio。另一个思路是：Hook 到这个应用，给它单独指定一个输出设备，其它应用不能用，否则还是混音了，然后用前面的回放录音技术录制这个独占的输出设备。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1498766" href="https://my.oschina.net/umu618/blog/1498766">解决 ffplay 无法播放声音的问题</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-08-01 14:54:58</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>用 ffplay 播放 opus 文件，错误信息如下：> SDL_OpenAudio (2 channels, 48000 Hz): XAudio2: XAudio2Create() failed at open.  > SDL_OpenAudio (1 channels, 48000 Hz): XAudio2: XAudio2Create() failed at open.  > SDL_OpenAudio (2 channels, 44100 Hz): XAudio2: XAudio2Create() failed at open.  > SDL_OpenAudio (1 channels, 44100 Hz): XAudio2: XAudio2Create() failed at open.解决方法——在 ffplay.c 的  main 函数开头，加上：```#ifdef _WIN32CoInitializeEx(NULL, COINIT_MULTITHREADED);#endif```</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1499874" href="https://my.oschina.net/umu618/blog/1499874">OggFile's CRC checksum</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-08-02 22:31:23</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>这几天研究 live555，然而蛋疼滴发现它流化的 opus 文件，VLC 居然无法播放，于是想了解一下 opus 文件，看了 live555 的 OggFileParser 代码，发现 checksum 都被无视了，本来 UMU 也应该无视这个细节的，然而随便用自己以前写的 CRC32 代码验证了一下，居然不一样！而这份代码之前是测试过的，和 7-Zip 的 CRC-32 算出来是一致的。因为 opus 文件是基于 ogg 文件格式的，所以阅读了一下 [Ogg Documentation](https://www.xiph.org/ogg/doc/framing.html)，发现确实不一样，它用的其实是 CRC32_IEEE，于是参考了 libogg 的 framing.c 和 ffmpeg\libavutil\crc.c 把自己的代码库给更新了，使用模版增强功能：```#pragma region "CRC"// CRC_8_ATM        // CRC_16_ANSI      // CRC_16_CCITT     // CRC_24_IEEE      // CRC_32_IEEE        -> OggFile's Checksum// CRC_32_IEEE_LE   // CRC_16_ANSI_LE   // defualt          , 7 - Zip's CRC-32template class CRC{public:    CRC()    {        static_assert (kBits >= 8 && kBits  0; --j) {                    crc = (crc >> 1) ^ (kPolynomial & (-static_cast(crc & 1)));                }                crc32_table_[i] = crc;            } else {                register uint32_t crc = i  0; --j) {                    crc = (crc (crc) >> 31));                }                crc32_table_[i] = be2me_32(crc);            }        }    }    uint32_t GetCRC(uint32_t crcinit, const uint8_t* data, size_t data_size)    {        register uint32_t crc = crcinit ^ kXorOut;        /* process not aligned message head */        for (; (3 & (data - (uint8_t*)0)) && data_size > 0; ++data, --data_size) {            crc = crc32_table_[static_cast(crc) ^ *data] ^ (crc >> 8);        }        /* fast CRC32 calculation of a DWORD-aligned message */        for (const uint8_t* e = data + (data_size & ~15); data (data));            crc = crc32_table_[crc & 0xFF] ^ (crc >> 8);            crc = crc32_table_[crc & 0xFF] ^ (crc >> 8);            crc = crc32_table_[crc & 0xFF] ^ (crc >> 8);            crc = crc32_table_[crc & 0xFF] ^ (crc >> 8);        }        /* process not aligned message tail */        for (const uint8_t* e = data + (data_size & 15); data (crc) ^ *data] ^ (crc >> 8);        }        return crc ^ kXorOut;    }private:    uint32_t crc32_table_[256];};#pragma endregion```</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1510145" href="https://my.oschina.net/umu618/blog/1510145">OpenWRT PPTP 穿透</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-08-15 00:49:39</div>
                <div class='catalog'>分类：Embedded</div>
                                                                            </div>
            <div class='content'>　　刷了 OpenWRT trunk 版本后默认是不支持 PPTP passthrough 的，表现为 PC 在 OpenWRT 路由器子网内，拨号时认证很快就过了，但迟迟不能完成，最终报错误码 619，这是因为默认不支持 GRE 协议的 NAT。 　　官方就有解决方案，简单地说是运行一下两条： ```// 本文发布于 2016/04/29，由于包含**词语被隐藏了，重新编辑上线。opkg updateopkg install kmod-nf-nathelper-extra```　　立刻生效。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1512603" href="https://my.oschina.net/umu618/blog/1512603">ffmpeg 与 live555 宏定义冲突</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-08-18 11:03:06</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>一个工程同时使用了 ffmpeg 和 live555，结果一不注意就混乱了……原因如下：```// ffmpeg 的 error.h 里 include 了 errno.h，有以下定义：#define EAGAIN          11// 而 live555 的 NetCommon.h 里有以下定义：#ifdef EAGAIN#undef EAGAIN#endif// WSAEWOULDBLOCK == 10035#define EAGAIN WSAEWOULDBLOCK```很明显，live555 这么做，违背了面向对象的基本特征——封装，这种平台相关的抽象应该封装在源文件里面，而不是放在头文件。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1518039" href="https://my.oschina.net/umu618/blog/1518039">AAC 编码之 ADTS 头相关分析</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-08-21 15:15:00</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>之前在《[Opus 编解码遇到的怪事](https://my.oschina.net/umu618/blog/1094080)》说过一个因为编码器不同而导致的怪事的解决过程，最近又出现一例类似情况了。UMU 的任务是把从麦克风采集到的音频数据，直接编码成 AAC，然后用 live555 流化为 RTSP 协议，做服务端。其中涉及到一个 ADTS 头部的问题，理论上有没有 ADTS 都是可以的，各有可行的解决方案。但在阅读其他同事代码的时候，惊讶地发现，他特地把 ADTS 头给去掉了。而 UMU 调试时，发现 AVPacket 的数据里根本没有 ADTS 头，何来去掉之说？有了上次的经验，UMU 很快推测，我们俩用的编码器可能不同。后来验证，确实如此：ffmpeg 3.1 有两个 AAC 编码器，一个内置的，名字是 aac，另一个第三方的 libfdk_aac，商业使用 non-free。（以前还有其它两个第三方的，因为质量不行，已经被移除，ffmpeg 官网上有说明）默认的编译方式只有前者，后者需要使用 non-free 参数编译，基于后期的版权问题考虑，UMU 使用的是内置的 aac。但为了调查这个问题，UMU 特地编译并使用了 libfdk_aac，发现确实有不同。1. aac 编码出来的 AVPacket 是没有 ADTS 头的； libfdk_aac 则有。2. aac 不需要设置 profile，因为它默认使用 LC，而 libfdk_aac 支持很多中 profile，所以需要设置一个合适的。3. libfdk_aac 设置合适的 profile 字段，编码出来的 AVPacket 有 ADTS 头，VLC 可以播放，特地去掉 ADTS 头，VLC 也可以播放。4. 如果不设置 profile，默认是 FF_PROFILE_UNKNOWN，这时有 ADTS 头，但由于这个 ADTS 头里的 adts_buffer_fullness 不对，所以 VLC 无法播放，去掉反而可以。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1553339" href="https://my.oschina.net/umu618/blog/1553339">内存对齐还是需要重视的——XMMATRIX 为例</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-10-19 14:34:13</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>最近研究 D3D，搜了一个教材跟着学：[http://www.rastertek.com/dx11s2tut04.html](http://www.rastertek.com/dx11s2tut04.html)用 x64 的配置运行，完美，过了几天需要用 x86 测试，结果一运行，程序崩溃……赶紧排查问题，x64 的 Debug、Release 都是可以的，而 x86 则是 Debug 可以，Release 才会崩。开发环境是 VS2015，编译时曾经遇到一些错误和警告，是 UMU 自己消灭掉了，最后有一类警告应该是关键：> warning C4316: 'SystemClass': object allocated on the heap may not be aligned 16原因是 XMMATRIX 需要 16 字节对齐，但代码的作者把它塞在几个类里，然后去 new 这些类了……尝试把这些类从 heap 改为 stack，问题解决！八哥太多，不能轻易放任警告！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1573044" href="https://my.oschina.net/umu618/blog/1573044">数据库相关算法 之 xxHash</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-11-13 22:25:03</div>
                <div class='catalog'>分类：云存储</div>
                                                                            </div>
            <div class='content'>Extremely fast non-cryptographic hash algorithm [http://www.xxhash.com/ ](http://www.xxhash.com/)1. Extremely fast，超快，working at speeds close to RAM limits。看了代码，作者对 memcpy 这样的 CRT 函数都要去追究性能，嫌弃它在一些平台/编译器组合下，只是次优解；而且处处可见对内存对齐的优化。总之优化功力挺深。2. non-cryptographic，非加密型的 Hash。如果是 cryptographic hash algorithm，则输入的数据只要改变一个 bit，输出的 bits 就应该改变 50%，这样的安全性才合格。而非加密型，没有防破解“安全性”这个要求，仅要求“唯一性”。3. 通过 SMHasher 测试，这是一个专门测试 non-cryptographic hash 的工具，测试包括分布、碰撞、性能。4. It is proposed in two flavors, 32 and 64 bits. 32 位程序用 32 位库比较快，同理，64 位程序用 64 位库比较快。5. 多平台支持，包括硬件平台(Big Endian/Little Endian、不同 CPU 架构等) 和操作系统。多种语言实现。RocksDB、MySQL 用它。它可以用来实现 Bloom Filter。6. 库只有两个文件：xxhash.c、xxhash.h，BSD 2 协议。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1579190" href="https://my.oschina.net/umu618/blog/1579190">从 pthread_t 获得 PID 和 TID</a></h2>
            <div class='outline'>
                <div class='date'>时间：2017-11-24 10:37:23</div>
                <div class='catalog'>分类：Linux</div>
                                                                            </div>
            <div class='content'>pthread_t 其实是一个结构体指针，里面包含了 TID 和 PID，找出它的偏移量就行。在 Ubuntu 16.04.3 x64上测试通过。```int get_tid_from_pthread(pthread_t t){struct pthread_fake {void *nothing[90];pid_t tid;};struct pthread_fake* f = (struct pthread_fake*)t;return f->tid;}int get_pid_from_pthread(pthread_t t){struct pthread_fake {void *nothing[90];pid_t tid;pid_t pid;};struct pthread_fake* f = (struct pthread_fake*)t;return f->pid;}```</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1611654" href="https://my.oschina.net/umu618/blog/1611654">MacBook 只装 Windows 情况下更新 EFI 经验</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-01-23 10:48:45</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'># 1. SMC 可以用 rEFInd 更新，升级和降级都没问题。rEFInd 可以放在 U 盘里，按 Option 开机，选择从 U 盘启动，不需要改动硬盘。升级命令行：```SmcFlasher.efi -LoadApp Your.smc```降级命令行：```SmcFlasher.efi -force -update -LoadApp Your.smc```# 2. 建议 EFI 方式安装 Windows把 Windows 安装盘 ISO 解压放在 U 盘就行了，这样只能 EFI 安装，如果您费力去用某些工具（比如盗版的 UltraISO）把 ISO 烧写到 U 盘里，则可能出现传统的安装方式，不小心使用传统安装的话您将来会后悔。# 3. 更新 EFI 固件原理上讲，需要两个步骤：把固件更新包放在硬盘的 ESP 分区 /EFI/APPLE 目录下，比如：> /EFI/APPLE/FIRMWARE/MBP112_0142_B00.scap> /EFI/APPLE/EXTENSIONS/Firmware.scap然后写 NVRAM，指定这些文件。**如果您的硬盘上没有 ESP 分区（EFI 分区）则无法更新 EFI，即使您用有 ESP 分区的 U 盘启动也没用。**# 4. 没有 macOS 能不能更新 EFI 固件呢？当然可以……但是 2015 年后苹果已经不发布单独的固件更新包了，而且解压 pkg 的工具在 macOS 上找比较快，所以您可能需要 macOS 配合一下，不然要自己去找那些必要的文件和工具。所以，建议您在 U 盘上装个 macOS 会方便很多。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1617478" href="https://my.oschina.net/umu618/blog/1617478">云主机带宽测试一例：Windows Server 网络性能被 Linux 秒杀？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-02-02 16:52:53</div>
                <div class='catalog'>分类：Server</div>
                                                                            </div>
            <div class='content'># 前情用 iperf3 测试云主机不同系统之间能跑多少带宽。# 怪现象1. 两台 Windows Server 2012 R2 测试，带宽只能到 2.4Gbps；2. 两台 CentOS 6.8 测试，可以达到 4Gbps，不限制带宽的环境下可以到 16Gbps；3. CentOS 做 Client，Windows 做 Server，也只能跑到 2.4Gbps。# 排查过程## 1. 怀疑虚拟机不在同一台物理机上把测试用的虚拟机都迁移到一台物理机上，测试结果依然是 Linix 完胜 Windows Server。## 2. 怀疑系统的 TCP wscale 值差异抓包发现 iperf3 Windows 版用的 wscale 是 2，CentOS 版经过系统级的 TCP 参数调优后是 7，所以把目标放在调高 Windows 的 wscale。```netsh interface tcp set supplemental template=datacenternetsh interface tcp set global autotuninglevel=experimental```结果发现，这样设置后，带宽确实提高到 3.5Gbps，但 wscale 并没有变化。## 3. 怀疑 iperf3 Windows 版有毛病因为上面的 2 条命令可以增加其它应用的 wscale 到 7，但 iperf3 不受影响，所以怀疑它有毛病。看了代码后，发现 Client 端用 -w 参数就可以让 Server 的 SO_RCVBUF 也使用 Client 设置的值，然后加上 -w 16000000 和 -w 32000000 分别测试，发现带宽还是无法提高，甚至有点下降。但到这里，我们可以得出结论：Windows 机器之间带宽上不去，并非因为 wscale 小。## 4. 怀疑是虚拟机服务器和客户机系统驱动之间有关联云主机是虚拟机，它跑在 Linux 的物理机上，有可能一脉相承的 Linux 的驱动设计得比较好，所以 Linux 的虚拟机网络性能更高。带着这个怀疑，稣在 Hype-V Server 上开了两个 Ubuntu 上测试，并优化了 TCP 参数：```echo "88584 118114 177168" | sudo tee /proc/sys/net/ipv4/tcp_mem```结果也才 2-3Gbps 左右……不玩了。总之，物理机什么系统，客户机最好也是一样的，毕竟有血缘关系。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1617666" href="https://my.oschina.net/umu618/blog/1617666">Ceph 慢盘原因分析一例：CPU 偷懒了！</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-02-02 17:36:30</div>
                <div class='catalog'>分类：云存储</div>
                                                                            </div>
            <div class='content'># 前情有一个 osd 慢了，想分析原因。# 分析过程## 1. 硬件配置对比找了一台参照机器，上面也一样跑了 15 个 osd，发现 CPU、内存、主板、内存、硬盘的型号都一样，参数也没看出明显差别。但磁盘有点毛病，用 smartctl 看不出通电时长，所以也没有法断定不是磁盘之间的差异。> ProLiant DL380e Gen8> > Intel(R) Xeon(R) CPU E5-2470 0 @ 2.30GHz> > 16G DDR3 1333 MHz * 10## 2. 排除配置差异确实找出一个差异来，这个慢的 osd 的磁盘分区和别的 osd 不一样，前面 14 个 osd 的 journal 分区占整个硬盘的比例是 20%，这个慢的 osd 则是 10%。但后来发现，其它 14 个是普通的 osd，慢的那个是 bucket index osd，所以分区故意那样分的。## 3. 发现 mcelog 大了很多慢盘的 mcelog 比参照机器上的大了 20G，后确认是很早以前有内存错误打的，不是最近发生。## 4. 怀疑内存还是有毛病，毕竟曾经有过毛病测试了逐字节内存填写，结果发现慢盘机器总是比参照机器慢一些，而且浮动比较大，所以怀疑是整机性能不行，并非就那个 bucket index osd 慢，只是 bucket index osd 慢得比较明显。后来，另一名同事确认了这点，15 个 osd 都比参照机器上的 15 个 osd 慢。## 5. 在另一名同事的协助下，发现 CPU 降频了……这个问题机器的 CPU 是 ondemand 模式，降频后，没有及时恢复！后来改为性能模式，问题解决。至于为什么 CPU 不能恢复高频模式，有点怀疑是 pcc-cpufreq.ko 这个 cpufreq_driver 的 bug，但没仔细研究了，直接听取前辈的经验：使用 ondemand 模式，可能导致莫名其妙的问题，而且并不能省多少电，意义不大。单说 CPU，省电的关键应该是把工作电压降低了，功率下降肯定能省电；只把频率降低（能提高电阻？），效果目测是不会很明显。这个研究不深，欢迎指教。## 6. 为什么参照机器没有问题？两个可能性：（1）BIOS ROM 版本不一样，参照机器更高：P73 08/20/2012，问题机器：P73 06/01/2012。（2）BIOS 参数可能也不一样。（服务器不能，无法查看……）</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1617683" href="https://my.oschina.net/umu618/blog/1617683">Mongo Shell 下批量更新集合</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-02-02 17:57:47</div>
                <div class='catalog'>分类：云存储</div>
                                                                            </div>
            <div class='content'># 需求延长 mongodb 某集合里的“过期时间”字段。# 风险分析update 一下是很简单，主要怕在 Shell 下操作可能改变数字类型。先做了实验，发现 3.2 的版本下，并没有这个问题，之前看书说，数字可能被改为双精度，看来是旧版本的不足。```db.UMU.find().forEach(function (doc) {    doc.expireDate = NumberLong(doc.updateTime + 180*24*60*60*1000);    db.UMU.save(doc);    })```其中 NumberLong 是必要的，不然更新后，expireDate 的类型并不是和 updateTime 一样的 NumberLong。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1634881" href="https://my.oschina.net/umu618/blog/1634881">[UMU 学 golang](6) 从 stdin 读取一行汉字</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-03-14 23:39:35</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'>水这篇的理由：搜了几篇出来，但居然不支持输入中文，赫赫……```func ScanLine() (line string) {var buffer []runefor {var c runen, err := fmt.Scanf("%c", &c)if nil != err || 1 != n || '\r' == c || '\n' == c {break}buffer = append(buffer, c)}return string(buffer)}```</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1648712" href="https://my.oschina.net/umu618/blog/1648712">求模版函数地址</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-03-21 18:01:32</div>
                <div class='catalog'>分类：C++</div>
                                                                            </div>
            <div class='content'>最近用 WTL 写 Ribbon 界面，发现一个坑。# 先看 WTL9.1 的代码```static void (CharFormat::*Getk_[])(IPropertyStore*) = {    &CharFormat::Getk_Family,     &CharFormat::Getk_FontProperties_Size,     &CharFormat::Getk_MaskEffect,    &CharFormat::Getk_MaskEffect,    &CharFormat::Getk_MaskEffect,    &CharFormat::Getk_MaskEffect,    &CharFormat::Getk_VerticalPositioning,     &CharFormat::Getk_Color,     &CharFormat::Getk_Color,     &CharFormat::Getk_ColorType,    &CharFormat::Getk_ColorType,};```其中 Getk_MaskEffect 是个模版函数，实现如下：```template void Getk_MaskEffect(IPropertyStore* pStore){    if (SUCCEEDED(pStore->GetValue(key, &propvar)))    {        UIPropertyToUInt32(key, propvar, &uValue);        if ((UI_FONTPROPERTIES)uValue != UI_FONTPROPERTIES_NOTAVAILABLE)        {            dwMask |= t_dwMask;            dwEffects |= ((UI_FONTPROPERTIES) uValue == UI_FONTPROPERTIES_SET) ? t_dwEffects : 0;        }    }}```然后，在 VS2017 编译失败了……> 1>X:\WTL91_5321_Final\Include\atlribbon.h(422): error C2440: 'initializing': cannot convert from 'overloaded-function' to 'void (__thiscall WTL::RibbonUI::CharFormat::* )(IPropertyStore *)'>> 1>X:\WTL91_5321_Final\Include\atlribbon.h(422): note: None of the functions with this name in scope match the target type然后根据错误提示搜到：Cannot take address of template function，[https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39018](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39018)，翻译一下：模版函数的地址转化，分两步走，第一步先转具化，第二步转目标类型，这样可以；直接转过去不可以！# 再来看看 WTL10 怎么解决这个问题的！```static void (CharFormat::*Getk_[])(IPropertyStore*) = {    &CharFormat::Getk_Family,     &CharFormat::Getk_FontProperties_Size,     &CharFormat::Getk_MaskEffectBold,    &CharFormat::Getk_MaskEffectItalic,    &CharFormat::Getk_MaskEffectUnderline,    &CharFormat::Getk_MaskEffectStrikeout,    &CharFormat::Getk_VerticalPositioning,    &CharFormat::Getk_Color,     &CharFormat::Getk_ColorBack,     &CharFormat::Getk_ColorType,    &CharFormat::Getk_ColorTypeBack,};```原来的模版函数，已经替换成普通函数了……```void Getk_MaskEffectBold(IPropertyStore* pStore){    Getk_MaskEffectAll(pStore, CFM_BOLD, CFE_BOLD, UI_PKEY_FontProperties_Bold);}void Getk_MaskEffectItalic(IPropertyStore* pStore){    Getk_MaskEffectAll(pStore, CFM_ITALIC, CFE_ITALIC, UI_PKEY_FontProperties_Italic);}void Getk_MaskEffectUnderline(IPropertyStore* pStore){    Getk_MaskEffectAll(pStore, CFM_UNDERLINE, CFE_UNDERLINE, UI_PKEY_FontProperties_Underline);}void Getk_MaskEffectStrikeout(IPropertyStore* pStore){    Getk_MaskEffectAll(pStore, CFM_STRIKEOUT, CFE_STRIKEOUT, UI_PKEY_FontProperties_Strikethrough);}void Getk_MaskEffectAll(IPropertyStore* pStore, DWORD _dwMask, DWORD _dwEffects, REFPROPERTYKEY key){    if (SUCCEEDED(pStore->GetValue(key, &propvar)))    {        UIPropertyToUInt32(key, propvar, &uValue);        if ((UI_FONTPROPERTIES)uValue != UI_FONTPROPERTIES_NOTAVAILABLE)        {            dwMask |= _dwMask;            dwEffects |= ((UI_FONTPROPERTIES)uValue == UI_FONTPROPERTIES_SET) ? _dwEffects : 0;        }    }}```</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1787996" href="https://my.oschina.net/umu618/blog/1787996">[UMU 学 golang](7) 设置进程退出码</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-03-31 20:45:49</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'># 常规方案直接用 os.Exit(exit_code)，但这个太暴力了，我们需要装逼一点的，于是找到了这个：[https://stackoverflow.com/questions/24601516/correct-way-to-set-exit-code-of-process](https://stackoverflow.com/questions/24601516/correct-way-to-set-exit-code-of-process)``` gopackage mainimport (    "fmt"    "os")func main() {    code := 0    defer func() {        os.Exit(code)    }()    defer func() {        fmt.Println("Another deferred func")    }()    fmt.Println("Hello, 世界")    code = 1}```# 问题调用 panic 的时候就知道以上的方法存在不足！panic 之后会导致 main 退出，本来紧接着应该打印 Trace Log，然而 main 退出时调用了 os.Exit()，然后没有然后了……果然是**装逼被雷劈**，本来 panic 时，退出码应该是 2 的，结果由于以上装逼代码的作用，退出码变成了 0！如果 panic 是自己主动调用的，那还可以改改，使用别的方式；如果是其它库函数的就难办了……</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1788799" href="https://my.oschina.net/umu618/blog/1788799">[UMU 学 golang](8) strings.Builder vs bytes.Buffer</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-04-02 18:47:56</div>
                <div class='catalog'>分类：golang</div>
                                                                            </div>
            <div class='content'># 先说优点- strings.Builder：省内存- bytes.Buffer：快# 性能测试程序``` gopackage benchmark_testimport ("bytes""strings""testing")var (ss = "1234567890abcdefghijklmnopqrstuvwxyz"bs = []byte(ss)rn = 'a'bt = byte('a'))func BenchmarkBuilderWrite(b *testing.B) {var builder strings.Builderfor i := 0; i < b.N; i++ {builder.Write(bs)}}func BenchmarkBuiderWriteByte(b *testing.B) {var builder strings.Builderfor i := 0; i < b.N; i++ {builder.WriteByte(bt)}}func BenchmarkBuilderWriteRune(b *testing.B) {var builder strings.Builderfor i := 0; i < b.N; i++ {builder.WriteRune(rn)}}func BenchmarkBuilderWriteString(b *testing.B) {var builder strings.Builderfor i := 0; i < b.N; i++ {builder.WriteString(ss)}}func BenchmarkBufferWrite(b *testing.B) {var buffer bytes.Bufferfor i := 0; i < b.N; i++ {buffer.Write(bs)}}func BenchmarkBufferWriteByte(b *testing.B) {var buffer bytes.Bufferfor i := 0; i < b.N; i++ {buffer.WriteByte(bt)}}func BenchmarkBufferWriteRune(b *testing.B) {var buffer bytes.Bufferfor i := 0; i < b.N; i++ {buffer.WriteRune(rn)}}func BenchmarkBufferWriteString(b *testing.B) {var buffer bytes.Bufferfor i := 0; i < b.N; i++ {buffer.WriteString(ss)}}```</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1796683" href="https://my.oschina.net/umu618/blog/1796683">考题：正则表达式 .*? 和 .* 有区别吗？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-04-17 13:00:17</div>
                <div class='catalog'>分类：考题</div>
                                                                            </div>
            <div class='content'>表面上看是一样的，但贪婪程度不一样。前者非贪婪模式，后者贪婪模式。# 例 1UMUUUUUUMUU{3,5} 匹配 5 个 UU{3,5}? 匹配 3 个 U# 例 2UMU618UMUTech\>.*UMU618UMUTech.*?UMU618<</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1797528" href="https://my.oschina.net/umu618/blog/1797528">更新知识库：WinHttpConnect 并不 TCP Connect 和 Punycode</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-04-18 22:47:28</div>
                <div class='catalog'>分类：Programming Windows</div>
                                                                            </div>
            <div class='content'>　　最近开发 [WCS go SDK](https://github.com/Wangsu-Cloud-Storage/wcs-go-sdk)，用 go 的 http client 觉得十分便捷，前几天在调试过程中，突然想起很多年前用 WinHttp API 写的一个下载程序，当时看到 WinHttpConnect 顾名思义就以为调完这个 API 后应该有 TCP 连接，现在仔细思考后觉得不合理，于是打开那个代码研究一下，果然以前想当然是错的！　　用 TcpView 和 Microsoft Network Monitor 抓包，都没发现 WinHttpConnect 成功之后有任何 TCP 连接。　　回头去看 MSDN 的描述，果然从头到尾没提到 TCP 连接。不过意外在文档里学到了一个新知识：[Punycode](https://baike.baidu.com/item/Punycode)，其实是老知识，以前没去深挖，熟视无睹而已。所有中文域名的解析都需要转成 punycode 码，然后由 DNS 解析 punycode 码。目前所说和各种浏览器完美支持中文域名，只是浏览器软件里面主动加入了中文域名自动转码，不需要原来的再次安装中文域名转码控件来完成整个流程。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1800671" href="https://my.oschina.net/umu618/blog/1800671">MongoDB Shard ID hash 算法 std::hash 的跨平台性</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-04-24 23:18:11</div>
                <div class='catalog'>分类：云存储</div>
                                                                            </div>
            <div class='content'>```#include #include #include #include int main(){    std::string str = "Meet the new boss...";    std::size_t str_hash = std::hash{}(str);    std::cout {}(str);    std::cout {}(str);    std::cout {}(str);    std::cout  hash("Meet the new boss...") = 5935324269489717502>> hash("Meet the new boss..;") = 5935347359233909933>> hash("Meet the new boss../") = 5935325369001345713>> hash("Meet the new boss..,") = 5935322070466461080Ubuntu 16.04,  g++ 5.4.0 20160609 的结果：> hash("Meet the new boss...") = 10656026664466977650>> hash("Meet the new boss..;") = 12509209616339026574>> hash("Meet the new boss../") = 6552276210272946664>> hash("Meet the new boss..,") = 15639609178671340058还好我们不会在生产环境，使用 Windows 部署 MongoDB……```std::size_t ShardId::Hasher::operator()(const ShardId& shardId) const {     return std::hash()(shardId._shardId); } ```详见：[https://github.com/mongodb/mongo/blob/master/src/mongo/s/shard_id.cpp](https://github.com/mongodb/mongo/blob/master/src/mongo/s/shard_id.cpp)这个 std::hash 在 x86 和 x64 下都不一样，所以，让我们看看 MongoDB 如何解决这个问题：MongoDB 3.4 no longer supports 32-bit x86 platforms.好样的！</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1805272" href="https://my.oschina.net/umu618/blog/1805272">C/C++ 数字后缀引发的处女座纠结</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-05-01 20:26:23</div>
                <div class='catalog'>分类：考题</div>
                                                                            </div>
            <div class='content'>对于 uint64_t 的常量，以前只写 Windows 平台的代码，所以习惯加上 Ui64 的后缀，前几天发现 g++ 不支持，于是改为 ULL，然后又测试了 ull，也是可以的，开始纠结以后是用大写还是小写……输入时是小写比大写方便，但小写的字母 l，容易被认成数字 1，比如 1234567890ll，看起来没 1234567890LL 容易辨认。看了 golang，并不支持数字加后缀，好样的！同样的纠结，还有十六进制的 0x 和 0X，abcdef 和 ABCDEF……golang 一样有这个纠结，看来要彻底的单一化还是不容易的。ATL 的 HexEncode 函数，输出的十六进制是大写的，UMU 也一直喜欢大写格式，但 std::hex 默认是小写，要用 std::setiosflags(std::ios::uppercase) 改大写。所以，如果自己实现一个 HexEncode 函数，默认还是应该返回小写格式的，这个道理很简单，您看一下键盘，上面都是大写字母，但按下去，不好意思，默认是小写，要大写？请按住 SHIFT。所以……处女座还是别学 C++ 的好。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_1822051" href="https://my.oschina.net/umu618/blog/1822051">学习 MongoDB 选举机制</a></h2>
            <div class='outline'>
                <div class='date'>时间：2018-05-31 18:25:32</div>
                <div class='catalog'>分类：Server</div>
                                                                            </div>
            <div class='content'>为了快速了解 MongoDB 选举机制，在网上找了一些文章来学习，后来发现里面提到的一些机制都过时了，尝试看代码了解，发现协议有 PV0 和 PV1 两种。代码：[https://github.com/mongodb/mongo/blob/r3.6.5/src/mongo/db/repl/topology_coordinator.cpp](https://github.com/mongodb/mongo/blob/r3.6.5/src/mongo/db/repl/topology_coordinator.cpp)一篇比较新的参考文章：[https://blog.csdn.net/wentyoon/article/details/78986174](https://blog.csdn.net/wentyoon/article/details/78986174)如果新选举出的主节点立马挂掉，至少需要 30s 重新选主，这个是由 leaseTime 常量决定的：const Seconds TopologyCoordinator::VoteLease::leaseTime = Seconds(30);PV0 时，一个反对会将最终票数减 10000，即在绝大多数情况下,只要有节点反对，请求的节点就不能成为主节点，由 prepareElectResponse 函数实现，里面有不少 vote = -10000;，PV1 版本取消了否决票。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_3209263" href="https://my.oschina.net/umu618/blog/3209263">技术博客迁移</a></h2>
            <div class='outline'>
                <div class='date'>时间：2020-03-23 18:26:37</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>旧时，觉得博客应该是分布式的，这样一个平台倒闭（说的就是百度空间）也损失不大……后来，总算学会了“专注”，差点唱出来，可惜跑调了。有一天，稣突然发现自己写过的博文散落在人间各地，自己管理都不方便……听说，独立域名逼格比较高（但也有一定风险）：</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_4780039" href="https://my.oschina.net/umu618/blog/4780039">云游戏即将起飞，这些技术您了解吗？</a></h2>
            <div class='outline'>
                <div class='date'>时间：2020-12-07 21:50:22</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'># 00 前言2019 年以前，基于当时的基础情况判断，大部分人不看好云游戏的产品形态。但是云游戏用的技术其实是很有含量，很值得研究的。不少云游戏开发者，能够冒着产品不被看好的风险硬啃这块，有很大原因是，其技术本身很有价值，很有挑战性。俗话说，高风险高回报，难道云游戏行业工资高这个秘密，我也要告诉您？2020 年上半年，由于疫情影响，实体娱乐业受到很大冲击，反而计算机游戏因此得利，不少上市游戏公司迎来一波股价上升行情。同时由于大头公司积极布局云游戏，大众开始对云游戏产品有所改观。到下半年，GPU、5G、边缘计算等领域的各种迹象已经表明云游戏起飞的时机大约就在 2021-2022 年。如果说之前，云游戏开发者是靠稀缺和承担高风险拿到高薪，那么今后两年，靠的就是趋势已来，赌对了！# 01 演示视频[国内首款开源云游戏引擎【鎏光】演示街头霸王对战](https://www.zhihu.com/zvideo/1314567244832530432) \- 知乎[国内首款开源云游戏引擎【鎏光】演示街头霸王对战](https://www.ixigua.com/6898563893564703239) \- 西瓜视频# 02 开源相信大部分开发者接到一个任务时，第一想法就是先找找有没有符合需求的现成的开源项目，如果有很多个，就做选型。即使没有完全符合要求的，接下来做开发，也可能是在拿一些开源的基础库做组合。很多时候，一个行业发达时，就必然会有很多相关开源项目。有些只是提供基础库，有些是产品级别的完整项目。今天咱们要介绍的，是一个准产品级别的完整项目——鎏光云游戏引擎。它大量依赖一些协议兼容的优秀基础开源库，不管是本身，还是其依赖，都是很值得参考的。[https://gitee.com/umu618/liuguang](https://gitee.com/umu618/liuguang)[https://github.com/ksyun-kenc/liuguang](https://github.com/ksyun-kenc/liuguang)当您 clone 好代码，把它们编译出一套可玩的“云游戏”成品后，可能会大呼过瘾，有种用零件造出变形金刚的快感，甚至很想参与完善它。我们很高兴地宣布，它的开源协议是 Apache 2.0，您可以尽情改造它。# 03 技术介绍项目的 [ReadMe](https://github.com/ksyun-kenc/liuguang/blob/master/README.zh-CN.md) 上已有相关说明，大家可以先大概看一下，再继续阅读。从最简化的模型上看，云游戏做的两件事是：把服务端的游戏画面“搬运”到客户端、把客户端的输入“搬运”到服务端。下面将按顺序介绍这两件事背后的细节。### Easyhook要“搬运”游戏画面，首先就得想办法抓取画面。大部分人会想起 QQ、飞书之类常用软件带的截图功能。这当然也可以，但考虑到“效率”，咱们不得不对各种截图技术做一些评估。GDI 抓图、NVIDIA FBC、MirrorDriver、DDA(Desktop Duplication API)、IDD(Indirect Display Driver)，这么多手段都可以抓图，但我们用的却是 Hook 抓图。举个例子，D3D 游戏本来调用一个叫 Present 的函数，告诉底层，我的数据准备好了，你可以拿去显示。云游戏引擎就 Hook 这个 Present 函数，抢先把游戏数据取走。Hook 方案有三个好处：最接近画面源头，延迟最小； 只抓游戏画面，不受遮挡影响。 黑科技：Hook 技术能控制游戏的垂直同步开关，使游戏按照特定规范运行，减少运营时的差异。可以还阻止游戏在本地显示，即在图中的渲染完成后，取得图像，之后的流程都抹掉，可以节省 GPU 资源，这是其它技术做不到的。我们选择的 Hook 库是 Easyhook，它是 MIT 协议：[EasyHook - The reinvention of Windows API Hooking](https://github.com/EasyHook/EasyHook)## FFmpeg接下来把画面流化属于流媒体范畴，不得不先提到大名鼎鼎的 FFmpeg。由于它属于 GPL/LGPL 协议，所以我们的代码内并没有放任何 FFmpeg 的文件，这需要开发者自己去放置。目前鎏光支持 H264 和 HEVC 两类编码，当采用 2020 年主流消费级 NVIDIA GPU 时，我们建议采用 HEVC 编码。如果您的 GPU 是其它品牌，还请自行修改代码，理论上只要是 FFmpeg 支持的硬件编码器，工作量几乎就是改个编码器的名字，也欢迎您调试好之后贡献代码。## IAudioCaptureClient这是 Windows 上的一个 COM 接口，用于抓声音。我们会采用 opus 或 aac 来编码声音，所以采集声音后会统一做个 resample，使数据符合编码器的要求。另外，鎏光的 Pro 版本还有针对单个进程抓声音的方案，采用 Hook IAudioRenderClient 的方式实现。参考：[云录音](https://my.oschina.net/umu618/blog/1476567)## WebSocket画面和声音流化之后得到一个个 AVPacket 数据块，当然还得把它们通过网络传输到客户端。这部分我们采用 WebSocket 协议，实现用的是 Boost.Beast。采用 Boost 的好处是，如果您想换成裸 TCP 传输，可以把 Boost.Beast 换成 Boost.Asio，改动很小。还有一个类似 Boost.Asio 的 kcp 库，是 GLP 协议的，所以我们没采用，但我们建议在互联网传输时使用 kcp，如果您想自己换，也是很方便的。## SDL客户端通过 WebScoket 拿到 AVPacket，同样采用 FFmpeg 解码得到 AVFrame，再从中拿到原始画面和声音，接下来该呈现给玩家了！我们采用 SDL 呈现画面和声音，它有跨平台的好处。值得一提的是，视频解码这步，我们是支持硬件解码的，并且我们通过对 SDL 实现的 hack，能够把硬解出来的视频帧直接丢给 SDL 去显示。玩家的操作，比如键盘、鼠标、手柄等外设的消息收集，也是通过 SDL 实现。## UDPSDL 采集的外设的消息封装后，通过裸 UDP 发送给服务端。采用 UDP 是为了保证实时性，并且丢包的代价不高，用户可以多按几次键盘鼠标就纠正丢包带来的问题。实现采用 Boost.Asio，和前面提过的一样，您可以很方便地自行把裸 UDP 改为 kcp。## 外设消息重放外设消息达到服务端后，还得将其发送给游戏。我们有两种做法，一种是通过 HID 驱动重放，一种是 Hook 游戏的外设 API，把客户端发来的消息返回给游戏。HID 驱动方案需要 WDK 开发，开发和部署的成本较大，但兼容性比较好，可以支持大部分游戏。Hook 方案的本质是：游戏用什么 API 读写外设消息，我们就 Hook 什么 API！它的好处是延迟低，然而游戏用的 API 还是蛮多可能的，DInput？RawInput？XInput？所以需要做多套 Hook。# 04 探讨您可能注意到前面 Hook 这个词出现挺多次。这其实是云游戏的重点和难点。如果采用云桌面思路来实现云游戏，其实可以不需要 Hook，而且一个桌面能干的事情更多，应用场景也会更多。按照这个路线发展的话，驱动会是重点和难点。但同时我们还应该注意到“原生云游戏”路线。原生云游戏不会采用任何驱动，甚至它的服务端不需要运行在 Windows 上。从原生云游戏 SDK 的角度看，它整个思路、流程和 Hook 方案的云游戏更像一些。您对哪者更感兴趣呢？欢迎留言告诉我们。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_4873803" href="https://my.oschina.net/umu618/blog/4873803">鎏光云游戏引擎 FAQ：对高刷新率的支持、与 Moonlight 的比较</a></h2>
            <div class='outline'>
                <div class='date'>时间：2021-01-02 12:47:30</div>
                <div class='catalog'>分类：流媒体开发</div>
                                                                            </div>
            <div class='content'>听本文音频：https://www.toutiao.com/i6912839526016631307/大家好，我是金山云的技术专家&mdash;&mdash;郑明，前面录过两个关于鎏光云游戏引擎的介绍视频，由于我主要把时间花在写代码上，只能忍痛割爱，没给视频加字幕。没办法，这个确实比较耗时&hellip;&hellip;这次就更厉害啦，干脆连视频也没了，就录个音。这次要聊的是鎏光的抓图技术。之所以谈这个，是因为有个老伙伴质问我：你的鎏光支持 120Hz 刷新率吗？还有网友说：鎏光和 moonlight 很像，想了解两者有何差别。我想了一下，这两个事儿其实可以一起谈。首先，咱们统一一下概念，这里提到 120Hz，其实想说的是高刷新率，相比主流的 60Hz，像 144Hz、300Hz 或更高的就统称高刷，老伙伴说的 120Hz 是拿 iPad Pro 的刷新率来举例。可以肯定的是&mdash;&mdash;鎏光支持高刷新率，而且它有个优势，就是不需要服务端接一个高刷新率的显示器。这里说的不需要，就是真的不需要，也不需要任何奇技淫巧、复杂配置，或外接显示器欺骗头之类的手段。事实上，看过前期视频的小伙伴应该知道，鎏光是支持服务端在远程桌面下工作的，可以说服务器上完全不接任何显示设备也没关系。原理也很简单，鎏光的抓图方案是通过 Hook 手段拿到游戏产生的画面，可以简单地认为鎏光每秒抓图的数量等于游戏的 fps。如果服务器上游戏的 fps 有 120 时，那么客户端接到的就也是 120 的 fps，这时候只要客户端的显示器支持 120Hz 刷新率，就能完美呈现出这 120 的 fps。其实了解鎏光的人会觉得问这个问题有点奇怪，我思考一番后，认为之所以有这么个质疑，很可能是因为这位老伙伴以前玩过 moonlight，因为 moonlight 抓的是整个屏幕，所以它抓图的速率是有个上限的，就是服务端显示器的刷新率，比如服务器接个 60Hz 的显示器，那么不管游戏的 fps 有多高，它每秒最多只能抓到 60 帧。此时，客户端用 120Hz 的显示器，就没法发挥作用了。moonlight 为了支持高刷新率，需要用点奇技淫巧，经过一阵骚操作和配置之后才可以，而鎏光是天然支持高刷新率。接下来聊聊 Hook 抓图的原理。上规模的游戏都会使用 3D API 来产生和显示游戏画面，比如 DirectX、OpenGL、Metal、Vulkan，他们都有共同的大致流程，游戏通过运算在显存产生一帧画面的数据，然后调用一个接口把这帧数据提交给显卡的前缓冲区，这个接口可能有不同名字，但我们先统一称为 Present。鎏光就是针对每种 3D API 的 Present 接口进行 Hook，经过每种 3D API 的相应操作，拿到游戏画面。这个方案的好处是能尽早地拿到游戏画面，其它抓图手段都会更晚一些。我们知道云游戏的一大难点就是要解决延迟！尽早地拿到游戏画面肯定是有帮助于降低延迟的。</div>
                    </div>
    
        <div class='blog'>
            <h2><a href="#top" class='top'>回到顶部</a><a name="blog_5494853" href="https://my.oschina.net/umu618/blog/5494853">平台默认不显示评论已经造成不必要的误会</a></h2>
            <div class='outline'>
                <div class='date'>时间：2022-03-20 00:00:31</div>
                <div class='catalog'>分类：工作日志</div>
                                                                            </div>
            <div class='content'>我没有屏蔽这位，本就很少上，所以没必要屏蔽任何人。是平台屏蔽的。![](https://oscimg.oschina.net/oscnet/up-845aaf89f8b59ca7b83e509feb7d7f8d67b.png)而且还不让发私信解释？说要 LV2 才能私信？无法交流了啊！![](https://oscimg.oschina.net/oscnet/up-5a2024d0f8b1a955570c627e98fa9f38336.png)</div>
                            <div class='commentList'>
                    <h3>评论列表</h3>
                                    </div>
                    </div>
    </div>
</body>
</html>
    

<!-- Generated by oschina (init:1[ms],page:133[ms],ip:116.233.205.247) //-->